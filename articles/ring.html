<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ring • ring</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="ring">
<meta property="og:description" content="ring">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    

    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">ring</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">1.0.4</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../articles/ring.html">Get started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/ring_applications.html">ring applications</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/mrc-ide/ring/" class="external-link">
    <span class="fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>ring</h1>
                        <h4 data-toc-skip class="author">Rich
FitzJohn</h4>
            
            <h4 data-toc-skip class="date">2023-04-28</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/mrc-ide/ring/blob/HEAD/vignettes/ring.Rmd" class="external-link"><code>vignettes/ring.Rmd</code></a></small>
      <div class="hidden name"><code>ring.Rmd</code></div>

    </div>

    
    
<p>This package implements <a href="https://en.wikipedia.org/wiki/Ring_buffer" class="external-link">ring buffers</a>. A
ring buffer can be used as a first-in-first-out (FIFO) buffer where the
maximum size is known ahead of time. Because they do not grow in size,
they are useful to avoid using more and more memory as a process runs.
Because the data reading and writing happens in an (apparently) circular
way, once data is added to the buffer it is not copied (in contrast if
you used a vector then every time data is consumed you’d have to shuffle
the vector around).</p>
<p><code>ring</code> implements two different ring buffers that will
likely suit different applications.</p>
<ul>
<li>
<code>ring_buffer_bytes</code> is implemented as a byte array in C,
possibly with a “stride” indicating a set of bytes that go together.
Once the data reaches the end of the array we start writing to the
beginning again.</li>
<li>
<code>ring_buffer_env</code> is implemented as a doubly linked list
using R’s environments. This buffer can hold arbitrary R objects at each
position.</li>
</ul>
<p>The target audience for this package is either other package
developers who need a ring buffer in their package, or modellers who
have decided that a ring buffer is the right data structure to help with
their simulation model.</p>
<p>For all buffers, <code>head</code> will refer to the next bit of the
buffer to be written to, and <code>tail</code> will refer to the next
bit of the buffer to be read. That is, elements are pushed onto the
<code>head</code> of the buffer and retrieved from the
<code>tail</code>. (There is no direct analogy between these terms and
the R functions <code>head</code> and <code>tail</code> which operate on
fixed-size vectors.)</p>
<div class="section level2">
<h2 id="the-environment-buffer-ring_buffer_env">The environment buffer <code>ring_buffer_env</code><a class="anchor" aria-label="anchor" href="#the-environment-buffer-ring_buffer_env"></a>
</h2>
<p>This is the simplest buffer to understand because we don’t have to
deal with raw vectors.</p>
<p>To create a buffer that can hold up to 100 elements, use the
<code>ring_buffer_env</code> function:</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">buf</span> <span class="op">&lt;-</span> <span class="fu">ring</span><span class="fu">::</span><span class="fu"><a href="../reference/ring_buffer_env.html">ring_buffer_env</a></span><span class="op">(</span><span class="fl">100</span><span class="op">)</span></span></code></pre></div>
<p>This is an <a href="https://github.com/r-lib/R6" class="external-link">R6</a> class, with
several methods:</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">buf</span></span></code></pre></div>
<pre><code><span><span class="co">## &lt;Ring Buffer (ring_buffer_env)&gt;</span></span>
<span><span class="co">##   Public:</span></span>
<span><span class="co">##     copy: function (dest, n)</span></span>
<span><span class="co">##     duplicate: function ()</span></span>
<span><span class="co">##     free: function ()</span></span>
<span><span class="co">##     grow: function (n)</span></span>
<span><span class="co">##     head: function ()</span></span>
<span><span class="co">##     head_advance: function ()</span></span>
<span><span class="co">##     head_data: function ()</span></span>
<span><span class="co">##     head_offset: function (n)</span></span>
<span><span class="co">##     head_pos: function ()</span></span>
<span><span class="co">##     head_set: function (data)</span></span>
<span><span class="co">##     is_empty: function ()</span></span>
<span><span class="co">##     is_full: function ()</span></span>
<span><span class="co">##     mirror: function (dest)</span></span>
<span><span class="co">##     push: function (data, iterate = TRUE)</span></span>
<span><span class="co">##     read: function (n)</span></span>
<span><span class="co">##     read_head: function (n)</span></span>
<span><span class="co">##     reset: function (clear = FALSE)</span></span>
<span><span class="co">##     set: function (data, n)</span></span>
<span><span class="co">##     size: function ()</span></span>
<span><span class="co">##     tail: function ()</span></span>
<span><span class="co">##     tail_offset: function (n)</span></span>
<span><span class="co">##     tail_pos: function ()</span></span>
<span><span class="co">##     take: function (n)</span></span>
<span><span class="co">##     take_head: function (n)</span></span>
<span><span class="co">##     used: function ()</span></span></code></pre>
<p>Operations on the class happen by running methods using
<code>$</code>. So the size of the buffer:</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">buf</span><span class="op">$</span><span class="fu">size</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 100</span></span></code></pre>
<p>…the number of elements free and used:</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">buf</span><span class="op">$</span><span class="fu">free</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 100</span></span></code></pre>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">buf</span><span class="op">$</span><span class="fu">used</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 0</span></span></code></pre>
<p>…whether the buffer is empty or full:</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">buf</span><span class="op">$</span><span class="fu">is_empty</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] TRUE</span></span></code></pre>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">buf</span><span class="op">$</span><span class="fu">is_full</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] FALSE</span></span></code></pre>
<p>To start using the buffer we need to put some data in it. There are
two main functions for adding data:</p>
<ul>
<li>
<code>buf$set(data, n)</code> sets <code>n</code> elements to be the
value <code>data</code>
</li>
<li>
<code>buf$push(data, iterate)</code> pushes <code>data</code> into
the buffer, with the <code>iterate</code> argument indicating if we
should iterate over <code>data</code> or treat it as a single
element</li>
</ul>
<p>So to set the first 5 elements to be “a”, “b”, …, “e”, use:</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">buf</span><span class="op">$</span><span class="fu">push</span><span class="op">(</span><span class="va">letters</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">5</span><span class="op">]</span><span class="op">)</span></span></code></pre></div>
<p>The buffer is no longer empty</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">buf</span><span class="op">$</span><span class="fu">is_empty</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] FALSE</span></span></code></pre>
<p>…having 5 elements:</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">buf</span><span class="op">$</span><span class="fu">used</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 5</span></span></code></pre>
<p>…and room for 95 more:</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">buf</span><span class="op">$</span><span class="fu">free</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 95</span></span></code></pre>
<p>To read the content of the buffer without modifying it, use
<code>read(n)</code> where <code>n</code> is the number of elements to
read. This <em>always</em> returns a list of length <code>n</code>:</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">buf</span><span class="op">$</span><span class="fu">read</span><span class="op">(</span><span class="fl">1</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [[1]]</span></span>
<span><span class="co">## [1] "a"</span></span></code></pre>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">buf</span><span class="op">$</span><span class="fu">read</span><span class="op">(</span><span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [[1]]</span></span>
<span><span class="co">## [1] "a"</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## [[2]]</span></span>
<span><span class="co">## [1] "b"</span></span></code></pre>
<p>If you try to read too far, then the buffer will underflow and you
will get an error:</p>
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">buf</span><span class="op">$</span><span class="fu">read</span><span class="op">(</span><span class="fl">20</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Error: Buffer underflow (requested 20 elements but 5 available)</span></span></code></pre>
<p>If you just want the the first element, use <code><a href="https://rdrr.io/r/utils/head.html" class="external-link">tail()</a></code></p>
<div class="sourceCode" id="cb27"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">buf</span><span class="op">$</span><span class="fu">tail</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] "a"</span></span></code></pre>
<p>The tail returns the first element in (so the buffer naturally
operates as a first-in-first-out queue).</p>
<p>You can also read the most recently added element with
<code><a href="https://rdrr.io/r/utils/head.html" class="external-link">head()</a></code></p>
<div class="sourceCode" id="cb29"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">buf</span><span class="op">$</span><span class="fu">head</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] "e"</span></span></code></pre>
<p>And you can offset these by an integer number of steps. So moving one
position into the buffer from the tail gets the second element
added:</p>
<div class="sourceCode" id="cb31"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">buf</span><span class="op">$</span><span class="fu">tail_offset</span><span class="op">(</span><span class="fl">1</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] "b"</span></span></code></pre>
<p>or moving three elements into the buffer from the head (most recently
added element) gets the same bit of data</p>
<div class="sourceCode" id="cb33"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">buf</span><span class="op">$</span><span class="fu">head_offset</span><span class="op">(</span><span class="fl">3</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] "b"</span></span></code></pre>
<p>The above operations are all nondestructive – they leave the buffer
unchanged. To consume elements, use <code>take(n)</code> which operates
the same way as <code>read</code> but it also moves the buffer
<code>tail</code>; it consumes elements leaving space for more.</p>
<div class="sourceCode" id="cb35"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">buf</span><span class="op">$</span><span class="fu">free</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 95</span></span></code></pre>
<div class="sourceCode" id="cb37"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">buf</span><span class="op">$</span><span class="fu">take</span><span class="op">(</span><span class="fl">1</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [[1]]</span></span>
<span><span class="co">## [1] "a"</span></span></code></pre>
<div class="sourceCode" id="cb39"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">buf</span><span class="op">$</span><span class="fu">free</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 96</span></span></code></pre>
<p>Now we have consumed an element the tail has moved along, so
<code>tail</code> contains “b” and “a” is removed from the buffer:</p>
<div class="sourceCode" id="cb41"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">buf</span><span class="op">$</span><span class="fu">tail</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] "b"</span></span></code></pre>
<p>To reset the buffer, use <code>reset()</code>. This empties the
buffer of all data:</p>
<div class="sourceCode" id="cb43"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">buf</span><span class="op">$</span><span class="fu">reset</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">buf</span><span class="op">$</span><span class="fu">used</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 0</span></span></code></pre>
<div class="sourceCode" id="cb45"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">buf</span><span class="op">$</span><span class="fu">is_empty</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] TRUE</span></span></code></pre>
<p>While the ring buffer is fixed in size in typical use, you can grow
it explicitly. To add additional space, use the <code>grow</code>
method:</p>
<div class="sourceCode" id="cb47"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">buf</span><span class="op">$</span><span class="fu">size</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 100</span></span></code></pre>
<div class="sourceCode" id="cb49"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">buf</span><span class="op">$</span><span class="fu">grow</span><span class="op">(</span><span class="fl">20</span><span class="op">)</span></span>
<span><span class="va">buf</span><span class="op">$</span><span class="fu">size</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 120</span></span></code></pre>
<div class="section level3">
<h3 id="application-simulation-with-recent-history">Application: simulation with recent history<a class="anchor" aria-label="anchor" href="#application-simulation-with-recent-history"></a>
</h3>
<p>The whole point of the ring buffer though is that we can push things
onto it and pull the most recent out, even when the number of things
pushed <em>overall</em> is larger than the buffer size.</p>
<p>So imagine a simulation where we need to keep track of the last 5
steps. The simulation is a random walk.</p>
<div class="sourceCode" id="cb51"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">step</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="kw">if</span> <span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span> <span class="op">&lt;</span> <span class="fl">0.5</span><span class="op">)</span> <span class="va">x</span> <span class="op">-</span> <span class="fl">1L</span> <span class="kw">else</span> <span class="va">x</span> <span class="op">+</span> <span class="fl">1L</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="va">x</span> <span class="op">&lt;-</span> <span class="fl">0L</span></span>
<span><span class="va">buf</span> <span class="op">&lt;-</span> <span class="fu">ring</span><span class="fu">::</span><span class="fu"><a href="../reference/ring_buffer_env.html">ring_buffer_env</a></span><span class="op">(</span><span class="fl">5</span><span class="op">)</span></span>
<span><span class="va">h</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/integer.html" class="external-link">integer</a></span><span class="op">(</span><span class="fl">20</span><span class="op">)</span></span>
<span><span class="va">buf</span><span class="op">$</span><span class="fu">push</span><span class="op">(</span><span class="va">x</span><span class="op">)</span></span>
<span><span class="va">h</span><span class="op">[</span><span class="fl">1L</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">x</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span></span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq_len</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">h</span><span class="op">)</span> <span class="op">-</span> <span class="fl">1L</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">x</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/step.html" class="external-link">step</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span></span>
<span>  <span class="va">buf</span><span class="op">$</span><span class="fu">push</span><span class="op">(</span><span class="va">x</span><span class="op">)</span></span>
<span>  <span class="va">h</span><span class="op">[</span><span class="va">i</span> <span class="op">+</span> <span class="fl">1L</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">x</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>The whole history:</p>
<div class="sourceCode" id="cb52"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">h</span></span></code></pre></div>
<pre><code><span><span class="co">##  [1]  0 -1 -2 -1  0 -1  0  1  2  3  2  1  0  1  0  1  0  1  2  1</span></span></code></pre>
<p>The last 5 steps:</p>
<div class="sourceCode" id="cb54"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/unlist.html" class="external-link">unlist</a></span><span class="op">(</span><span class="va">buf</span><span class="op">$</span><span class="fu">read</span><span class="op">(</span><span class="fl">5</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 1 0 1 2 1</span></span></code></pre>
<p>So we could rewrite the simulation so that the random walk tends up
if the last few steps have been increases and tends down if the last few
steps have been decreases:</p>
<div class="sourceCode" id="cb56"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">step</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="kw">if</span> <span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">&gt;</span> <span class="fl">1</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="va">p</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/diff.html" class="external-link">diff</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">)</span> <span class="op">/</span> <span class="fl">2</span> <span class="op">+</span> <span class="fl">0.5</span></span>
<span>  <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span>    <span class="va">p</span> <span class="op">&lt;-</span> <span class="fl">0.5</span></span>
<span>  <span class="op">}</span></span>
<span>  <span class="kw">if</span> <span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span> <span class="op">&lt;</span> <span class="va">p</span><span class="op">)</span> <span class="va">x</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">]</span> <span class="op">-</span> <span class="fl">1L</span> <span class="kw">else</span> <span class="va">x</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">]</span> <span class="op">+</span> <span class="fl">1L</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="va">x</span> <span class="op">&lt;-</span> <span class="fl">0L</span></span>
<span><span class="va">buf</span> <span class="op">&lt;-</span> <span class="fu">ring</span><span class="fu">::</span><span class="fu"><a href="../reference/ring_buffer_env.html">ring_buffer_env</a></span><span class="op">(</span><span class="fl">5</span><span class="op">)</span></span>
<span><span class="va">h</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/integer.html" class="external-link">integer</a></span><span class="op">(</span><span class="fl">100</span><span class="op">)</span></span>
<span><span class="va">buf</span><span class="op">$</span><span class="fu">push</span><span class="op">(</span><span class="va">x</span><span class="op">)</span></span>
<span><span class="va">h</span><span class="op">[</span><span class="fl">1L</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">x</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span></span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq_len</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">h</span><span class="op">)</span> <span class="op">-</span> <span class="fl">1L</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">x</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/step.html" class="external-link">step</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/unlist.html" class="external-link">unlist</a></span><span class="op">(</span><span class="va">buf</span><span class="op">$</span><span class="fu">read</span><span class="op">(</span><span class="va">buf</span><span class="op">$</span><span class="fu">used</span><span class="op">(</span><span class="op">)</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span>  <span class="va">buf</span><span class="op">$</span><span class="fu">push</span><span class="op">(</span><span class="va">x</span><span class="op">)</span></span>
<span>  <span class="va">h</span><span class="op">[</span><span class="va">i</span> <span class="op">+</span> <span class="fl">1L</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">x</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>Now we have a simulation with a strong mean reverting tendency:</p>
<div class="sourceCode" id="cb57"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/par.html" class="external-link">par</a></span><span class="op">(</span>mar <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">4</span>, <span class="fl">4</span>, <span class="fl">.5</span>, <span class="fl">.5</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">h</span>, type <span class="op">=</span> <span class="st">"l"</span>, xlab <span class="op">=</span> <span class="st">"step"</span>, ylab <span class="op">=</span> <span class="st">"y"</span>, las <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span></code></pre></div>
<p><img src="ring_files/figure-html/unnamed-chunk-25-1.png" width="672"></p>
<p>Because the buffer always holds the last 5 (or fewer) elements the
book-keeping involved in working with the last few elements out is
simplified. Ignoring the fact that we hold the entire history in the
fixed size vector <code>h</code>, only the last few elements need to be
retained which may be useful if the simulation generates a lot of
data.</p>
<p>A downside of this implementation is that <code>buf$read()</code>
returns a list that must be turned into a vector with
<code>unlist</code>, even though we know in this case that the
simulation will always produce an integer vector. The ring buffers
described below can help with that problem.</p>
</div>
</div>
<div class="section level2">
<h2 id="the-bytes-buffer-ring_buffer_bytes">The bytes buffer <code>ring_buffer_bytes</code><a class="anchor" aria-label="anchor" href="#the-bytes-buffer-ring_buffer_bytes"></a>
</h2>
<p>This is the classical implementation of a ring buffer, and the
implementation is broadly based on the one <a href="https://github.com/dhess/c-ringbuf" class="external-link">here</a>, by <a href="https://github.com/dhess" class="external-link">@dhess</a>.</p>
<p>This operates basically the same way as <code>ring_buffer_env</code>,
and presents a very similar interface to R, but with a few key
differences:</p>
<ul>
<li>The contents of the buffer are raw bytes (using R’s raw vectors).
These are a bit fiddly to work with but can be very powerful.</li>
<li>The <code>iterate</code> distinction of <code>push</code> disappears
because there is no ambiguity with R objects</li>
</ul>
<p>To construct a buffer of 1000 bytes:</p>
<div class="sourceCode" id="cb58"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">buf</span> <span class="op">&lt;-</span> <span class="fu">ring</span><span class="fu">::</span><span class="fu"><a href="../reference/ring_buffer_bytes.html">ring_buffer_bytes</a></span><span class="op">(</span><span class="fl">1000</span><span class="op">)</span></span></code></pre></div>
<p>Most of the same methods apply directly:</p>
<div class="sourceCode" id="cb59"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">buf</span><span class="op">$</span><span class="fu">free</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 1000</span></span></code></pre>
<div class="sourceCode" id="cb61"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">buf</span><span class="op">$</span><span class="fu">used</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 0</span></span></code></pre>
<div class="sourceCode" id="cb63"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">buf</span><span class="op">$</span><span class="fu">is_full</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] FALSE</span></span></code></pre>
<div class="sourceCode" id="cb65"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">buf</span><span class="op">$</span><span class="fu">is_empty</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] TRUE</span></span></code></pre>
<p>Generate a byte sequence:</p>
<div class="sourceCode" id="cb67"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">bytes</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/raw.html" class="external-link">as.raw</a></span><span class="op">(</span><span class="fl">0</span><span class="op">:</span><span class="fl">255</span><span class="op">)</span></span></code></pre></div>
<p>…and push them into the buffer:</p>
<div class="sourceCode" id="cb68"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">buf</span><span class="op">$</span><span class="fu">push</span><span class="op">(</span><span class="va">bytes</span><span class="op">)</span></span></code></pre></div>
<p>…read from the buffer</p>
<div class="sourceCode" id="cb69"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">buf</span><span class="op">$</span><span class="fu">read</span><span class="op">(</span><span class="fl">10</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##  [1] 00 01 02 03 04 05 06 07 08 09</span></span></code></pre>
<p>…destructively take the oldest elements</p>
<div class="sourceCode" id="cb71"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">buf</span><span class="op">$</span><span class="fu">used</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 256</span></span></code></pre>
<div class="sourceCode" id="cb73"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">buf</span><span class="op">$</span><span class="fu">take</span><span class="op">(</span><span class="fl">20</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##  [1] 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13</span></span></code></pre>
<div class="sourceCode" id="cb75"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">buf</span><span class="op">$</span><span class="fu">used</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 236</span></span></code></pre>
<div class="section level3">
<h3 id="striding">Striding<a class="anchor" aria-label="anchor" href="#striding"></a>
</h3>
<p>Single bytes can hold only values 0 to 255 (or character equivalents,
such as <code>a</code> becomes 61 via <code>charToRaw("a")</code>. But
if you want to hold a full integer, that (usually) takes 4 bytes, a
double (usually) takes 8.</p>
<p>To allow this, a bytes buffer can be “strided”; this indicates the
number of consecutive bytes that should together make up one logical
entry. The buffer then contains <code>size</code> of these. So to create
a buffer of 100 entries, each of <code>8</code> bytes you could do:</p>
<div class="sourceCode" id="cb77"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">buf</span> <span class="op">&lt;-</span> <span class="fu">ring</span><span class="fu">::</span><span class="fu"><a href="../reference/ring_buffer_bytes.html">ring_buffer_bytes</a></span><span class="op">(</span><span class="fl">100</span>, <span class="fl">8</span><span class="op">)</span></span></code></pre></div>
<p>Each element pushed onto the buffer must have the correct size. So to
push the byte sequence 1..8 onto the buffer:</p>
<div class="sourceCode" id="cb78"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">buf</span><span class="op">$</span><span class="fu">push</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/raw.html" class="external-link">as.raw</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">8</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>but if you pushed more or less it would be an error:</p>
<div class="sourceCode" id="cb79"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">buf</span><span class="op">$</span><span class="fu">push</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/raw.html" class="external-link">as.raw</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">4</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Error in buf$push(as.raw(1:4)): Incorrect size data (4 bytes); expected multiple of 8 bytes</span></span></code></pre>
<p>Reading happens in <em>logical</em> units, not bytes:</p>
<div class="sourceCode" id="cb81"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">buf</span><span class="op">$</span><span class="fu">read</span><span class="op">(</span><span class="fl">1</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 01 02 03 04 05 06 07 08</span></span></code></pre>
<p>and you can get the number of elements used:</p>
<div class="sourceCode" id="cb83"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">buf</span><span class="op">$</span><span class="fu">used</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 1</span></span></code></pre>
<p>or the number of bytes</p>
<div class="sourceCode" id="cb85"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">buf</span><span class="op">$</span><span class="fu">used</span><span class="op">(</span>bytes <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 8</span></span></code></pre>
</div>
<div class="section level3">
<h3 id="the-typed-bytes-buffer-ring_buffer_bytes_typed">The typed bytes buffer <code>ring_buffer_bytes_typed</code><a class="anchor" aria-label="anchor" href="#the-typed-bytes-buffer-ring_buffer_bytes_typed"></a>
</h3>
<p>If 8 bytes is a double, it should be possible to make a bytes buffer
that holds one (or more) doubles per entry. That is what the
<code>ring_buffer_bytes_typed</code> buffer does, with a few corner
cases dealt with. To use, you decide what the <em>R interpretation</em>
of an entry is, it will determine the size per entry and appropriate
encoding and decoding functions and you can ignore that it is storing
bytes. For performance reasons this does not use R’s serialisation and
simply copies the data stored in vectors.</p>
<p>For example, to make a buffer of 10 elements, each of which is a
single real number (double), use:</p>
<div class="sourceCode" id="cb87"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">buf</span> <span class="op">&lt;-</span> <span class="fu">ring</span><span class="fu">::</span><span class="fu"><a href="../reference/ring_buffer_bytes_typed.html">ring_buffer_bytes_typed</a></span><span class="op">(</span><span class="fl">10</span>, <span class="fu"><a href="https://rdrr.io/r/base/double.html" class="external-link">double</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>onto which real numbers can be pushed:</p>
<div class="sourceCode" id="cb88"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">buf</span><span class="op">$</span><span class="fu">push</span><span class="op">(</span><span class="va">pi</span><span class="op">)</span></span></code></pre></div>
<p>And retrieve the data.</p>
<div class="sourceCode" id="cb89"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">buf</span><span class="op">$</span><span class="fu">take</span><span class="op">(</span><span class="fl">1</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 3.141593</span></span></code></pre>
<p>Entries can contain more than one number; to make a buffer of length
10, each element of which is a vector of 5 doubles:</p>
<div class="sourceCode" id="cb91"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">buf</span> <span class="op">&lt;-</span> <span class="fu">ring</span><span class="fu">::</span><span class="fu"><a href="../reference/ring_buffer_bytes_typed.html">ring_buffer_bytes_typed</a></span><span class="op">(</span><span class="fl">10</span>, <span class="fu"><a href="https://rdrr.io/r/base/double.html" class="external-link">double</a></span><span class="op">(</span><span class="fl">5</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">buf</span><span class="op">$</span><span class="fu">push</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="fl">5</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">buf</span><span class="op">$</span><span class="fu">read</span><span class="op">(</span><span class="fl">1</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1]  0.26613736 -0.37670272  2.44136463 -0.79533912 -0.05487747</span></span></code></pre>
<p>Because this is just implemented as a byte array, we can just push a
bunch of numbers straight into the buffer:</p>
<div class="sourceCode" id="cb93"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">buf</span><span class="op">$</span><span class="fu">push</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="fl">5</span> <span class="op">*</span> <span class="fl">10</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>With elements in the buffer, we can request them. The integer
argument of <code>take</code> indicates the number of groups of 5
doubles we would like back:</p>
<div class="sourceCode" id="cb94"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">buf</span><span class="op">$</span><span class="fu">take</span><span class="op">(</span><span class="fl">1</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1]  0.2501413  0.6182433 -0.1726235 -2.2239003 -1.2636144</span></span></code></pre>
<p>If you try to take more than is in the buffer it is an error:</p>
<div class="sourceCode" id="cb96"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">buf</span><span class="op">$</span><span class="fu">take</span><span class="op">(</span><span class="fl">10</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Error in super$take(n): Buffer underflow (requested 10 elements but 9 available)</span></span></code></pre>
</div>
<div class="section level3">
<h3 id="the-translating-bytes-buffer-ring_buffer_bytes_translate">The translating bytes buffer
<code>ring_buffer_bytes_translate</code><a class="anchor" aria-label="anchor" href="#the-translating-bytes-buffer-ring_buffer_bytes_translate"></a>
</h3>
<p>The <code>ring_buffer_bytes_typed</code> function is implemented by
translating R objects to bytes (when storing with <code>$set()</code>,
<code>$push()</code>, etc). and from bytes back to R objects (when
retrieving with <code>$read()</code>, <code>$take()</code>, etc).
<code>ring_buffer_bytes_translate</code> exposes this interface.</p>
<p>The “typed” buffers do not allow storing strings because they can be
any number of bytes long (the bytes buffers require a fixed “stride”
within a buffer). But we can store fixed length strings.</p>
<p>To convert a string to a byte sequence, use <code>charToRaw</code>
(or <code>as.raw(utf8ToInt(x))</code>, but then multi-byte sequences
might start being difficult).</p>
<div class="sourceCode" id="cb98"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="op">(</span><span class="va">bytes</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/rawConversion.html" class="external-link">charToRaw</a></span><span class="op">(</span><span class="st">"hello world"</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##  [1] 68 65 6c 6c 6f 20 77 6f 72 6c 64</span></span></code></pre>
<p>The inverse transformation is <code>rawToChar</code> (or
<code>intToUtf8(as.integer(x))</code>):</p>
<div class="sourceCode" id="cb100"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/rawConversion.html" class="external-link">rawToChar</a></span><span class="op">(</span><span class="va">bytes</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] "hello world"</span></span></code></pre>
<p>The function <code>ring_buffer_bytes_translate</code> takes these
functions as its 3rd and fourth arguments. So to make a buffer that will
hold up to 100 strings, each of 8 bytes:</p>
<div class="sourceCode" id="cb102"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">b</span> <span class="op">&lt;-</span> <span class="fu">ring</span><span class="fu">::</span><span class="fu"><a href="../reference/ring_buffer_bytes_translate.html">ring_buffer_bytes_translate</a></span><span class="op">(</span><span class="fl">100</span>, <span class="fl">8</span>, <span class="va">charToRaw</span>, <span class="va">rawToChar</span><span class="op">)</span></span></code></pre></div>
<p>We can now store 8 character strings:</p>
<div class="sourceCode" id="cb103"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">b</span><span class="op">$</span><span class="fu">push</span><span class="op">(</span><span class="st">"abcdefgh"</span><span class="op">)</span></span>
<span><span class="va">b</span><span class="op">$</span><span class="fu">tail</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] "abcdefgh"</span></span></code></pre>
<p>But other length strings cannot be added:</p>
<div class="sourceCode" id="cb105"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">b</span><span class="op">$</span><span class="fu">push</span><span class="op">(</span><span class="st">"hello!"</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Error in super$push(self$.to(data)): Incorrect size data (6 bytes); expected multiple of 8 bytes</span></span></code></pre>
<p>Probably this would be most useful storing just single characters as
then it would make a buffer of <em>text</em>.</p>
</div>
</div>
<div class="section level2">
<h2 id="the-c-api">The C API<a class="anchor" aria-label="anchor" href="#the-c-api"></a>
</h2>
<p>The <code>ring</code> package can be used in other R packages using
the <code>LinkingTo</code> mechanism. To do so:</p>
<ul>
<li><p>In your <code>DESCRIPTION</code>, add a line
<code>LinkingTo: ring</code> (you do not need to include
<code>ring</code> in <code>Depends</code> or <code>Imports</code> as we
need it only for the package build).</p></li>
<li><p>In your <code>src/</code> directory, add a file
<code>ring.c</code> containing just the line
<code>#include &lt;ring/ring.c&gt;</code> (but see the note in the
documentation for <code>ring_buffer_create</code> below).</p></li>
<li><p>Anywhere in your code you want to use the ring buffer, include
the line <code>#include &lt;dde/dde.h&gt;</code> to include the
prototypes and use the interface as described below.</p></li>
</ul>
<p>(I am not sure what the best practice way of doing this with a
standalone shared library compiled with <code>R CMD SHLIB</code> is
though; probably best to make a package.)</p>
<p>The C API is documented only in the header file, and it should be
fairly straightforward to use (with reference to the docs above; this is
the code underlying the <code>ring_buffer_bytes</code> interface).</p>
<div class="sourceCode" id="cb107"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifndef _RING_H_</span></span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define _RING_H_</span></span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stddef.h&gt;</span></span>
<span id="cb107-4"><a href="#cb107-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdbool.h&gt;</span></span>
<span id="cb107-5"><a href="#cb107-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-6"><a href="#cb107-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifndef RING_USE_STDLIB_ALLOC</span></span>
<span id="cb107-7"><a href="#cb107-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifndef USING_R</span></span>
<span id="cb107-8"><a href="#cb107-8" aria-hidden="true" tabindex="-1"></a><span class="pp">#define USING_R</span></span>
<span id="cb107-9"><a href="#cb107-9" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb107-10"><a href="#cb107-10" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb107-11"><a href="#cb107-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-12"><a href="#cb107-12" aria-hidden="true" tabindex="-1"></a><span class="co">// Allow use from C++</span></span>
<span id="cb107-13"><a href="#cb107-13" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef __cplusplus</span></span>
<span id="cb107-14"><a href="#cb107-14" aria-hidden="true" tabindex="-1"></a><span class="kw">extern</span> <span class="st">"C"</span> <span class="op">{</span></span>
<span id="cb107-15"><a href="#cb107-15" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb107-16"><a href="#cb107-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-17"><a href="#cb107-17" aria-hidden="true" tabindex="-1"></a><span class="co">// What to do on overflow.</span></span>
<span id="cb107-18"><a href="#cb107-18" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-19"><a href="#cb107-19" aria-hidden="true" tabindex="-1"></a><span class="co">// The OVERFLOW_ERROR action (which calls R's error function) is only</span></span>
<span id="cb107-20"><a href="#cb107-20" aria-hidden="true" tabindex="-1"></a><span class="co">// available when using R, which is detected by the &lt;R.h&gt; header</span></span>
<span id="cb107-21"><a href="#cb107-21" aria-hidden="true" tabindex="-1"></a><span class="co">// included.  If you are using RING_USE_STDLIB_ALLOC (see below) but</span></span>
<span id="cb107-22"><a href="#cb107-22" aria-hidden="true" tabindex="-1"></a><span class="co">// want to use OVERFLOW_ERROR then you'll need to include &lt;R.h&gt; as</span></span>
<span id="cb107-23"><a href="#cb107-23" aria-hidden="true" tabindex="-1"></a><span class="co">// well, and be willing to deal with an R error and the longjmp that</span></span>
<span id="cb107-24"><a href="#cb107-24" aria-hidden="true" tabindex="-1"></a><span class="co">// it causes.</span></span>
<span id="cb107-25"><a href="#cb107-25" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">enum</span> overflow_action <span class="op">{</span></span>
<span id="cb107-26"><a href="#cb107-26" aria-hidden="true" tabindex="-1"></a>  OVERFLOW_OVERWRITE<span class="op">,</span></span>
<span id="cb107-27"><a href="#cb107-27" aria-hidden="true" tabindex="-1"></a>  OVERFLOW_GROW</span>
<span id="cb107-28"><a href="#cb107-28" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef USING_R</span></span>
<span id="cb107-29"><a href="#cb107-29" aria-hidden="true" tabindex="-1"></a>  <span class="op">,</span> OVERFLOW_ERROR</span>
<span id="cb107-30"><a href="#cb107-30" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb107-31"><a href="#cb107-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> overflow_action<span class="op">;</span></span>
<span id="cb107-32"><a href="#cb107-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-33"><a href="#cb107-33" aria-hidden="true" tabindex="-1"></a><span class="co">// The underlying data structure.  None of the fields here should be</span></span>
<span id="cb107-34"><a href="#cb107-34" aria-hidden="true" tabindex="-1"></a><span class="co">// directly accessed in normal use; use the accessor functions</span></span>
<span id="cb107-35"><a href="#cb107-35" aria-hidden="true" tabindex="-1"></a><span class="co">// instead.</span></span>
<span id="cb107-36"><a href="#cb107-36" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-37"><a href="#cb107-37" aria-hidden="true" tabindex="-1"></a><span class="co">// The ring buffer is a FIFO (first-in-first-out) queue.  It is</span></span>
<span id="cb107-38"><a href="#cb107-38" aria-hidden="true" tabindex="-1"></a><span class="co">// implemented as a single block of memory (data) and a pair of</span></span>
<span id="cb107-39"><a href="#cb107-39" aria-hidden="true" tabindex="-1"></a><span class="co">// pointers:</span></span>
<span id="cb107-40"><a href="#cb107-40" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-41"><a href="#cb107-41" aria-hidden="true" tabindex="-1"></a><span class="co">//   head: the starting location where data should be written when</span></span>
<span id="cb107-42"><a href="#cb107-42" aria-hidden="true" tabindex="-1"></a><span class="co">//         copying data *into* the buffer.</span></span>
<span id="cb107-43"><a href="#cb107-43" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-44"><a href="#cb107-44" aria-hidden="true" tabindex="-1"></a><span class="co">//   tail: the starting location where data should be read when</span></span>
<span id="cb107-45"><a href="#cb107-45" aria-hidden="true" tabindex="-1"></a><span class="co">//         copying data *from* the buffer.</span></span>
<span id="cb107-46"><a href="#cb107-46" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-47"><a href="#cb107-47" aria-hidden="true" tabindex="-1"></a><span class="co">// The buffer has a concept of a stride; the number of bytes per</span></span>
<span id="cb107-48"><a href="#cb107-48" aria-hidden="true" tabindex="-1"></a><span class="co">// buffer entry.  This is fixed across the entire ring.  As such, some</span></span>
<span id="cb107-49"><a href="#cb107-49" aria-hidden="true" tabindex="-1"></a><span class="co">// functions that return size_t have a booleanargument "bytes" that</span></span>
<span id="cb107-50"><a href="#cb107-50" aria-hidden="true" tabindex="-1"></a><span class="co">// switches between measuring in bytes and measuring in logical</span></span>
<span id="cb107-51"><a href="#cb107-51" aria-hidden="true" tabindex="-1"></a><span class="co">// elements.  In the case where stride=1, these are identical.</span></span>
<span id="cb107-52"><a href="#cb107-52" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-53"><a href="#cb107-53" aria-hidden="true" tabindex="-1"></a><span class="co">// In general, the ring buffer is totally happy to overflow; if you</span></span>
<span id="cb107-54"><a href="#cb107-54" aria-hidden="true" tabindex="-1"></a><span class="co">// write too much into the ring buffer it will destructively erase</span></span>
<span id="cb107-55"><a href="#cb107-55" aria-hidden="true" tabindex="-1"></a><span class="co">// data (i.e., your tail will move).  The ring buffer will never</span></span>
<span id="cb107-56"><a href="#cb107-56" aria-hidden="true" tabindex="-1"></a><span class="co">// underflow, but functions may return `NULL` on underflow - read the</span></span>
<span id="cb107-57"><a href="#cb107-57" aria-hidden="true" tabindex="-1"></a><span class="co">// documentation below carefully.</span></span>
<span id="cb107-58"><a href="#cb107-58" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">unsigned</span> <span class="dt">char</span> data_t<span class="op">;</span></span>
<span id="cb107-59"><a href="#cb107-59" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> ring_buffer <span class="op">{</span></span>
<span id="cb107-60"><a href="#cb107-60" aria-hidden="true" tabindex="-1"></a>  <span class="dt">size_t</span> size<span class="op">;</span></span>
<span id="cb107-61"><a href="#cb107-61" aria-hidden="true" tabindex="-1"></a>  <span class="dt">size_t</span> stride<span class="op">;</span></span>
<span id="cb107-62"><a href="#cb107-62" aria-hidden="true" tabindex="-1"></a>  <span class="dt">size_t</span> bytes_data<span class="op">;</span></span>
<span id="cb107-63"><a href="#cb107-63" aria-hidden="true" tabindex="-1"></a>  overflow_action on_overflow<span class="op">;</span></span>
<span id="cb107-64"><a href="#cb107-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-65"><a href="#cb107-65" aria-hidden="true" tabindex="-1"></a>  data_t <span class="op">*</span>data<span class="op">;</span></span>
<span id="cb107-66"><a href="#cb107-66" aria-hidden="true" tabindex="-1"></a>  data_t <span class="op">*</span>head<span class="op">;</span></span>
<span id="cb107-67"><a href="#cb107-67" aria-hidden="true" tabindex="-1"></a>  data_t <span class="op">*</span>tail<span class="op">;</span></span>
<span id="cb107-68"><a href="#cb107-68" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> ring_buffer<span class="op">;</span></span>
<span id="cb107-69"><a href="#cb107-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-70"><a href="#cb107-70" aria-hidden="true" tabindex="-1"></a><span class="co">//// Creation, deletion, etc: ////</span></span>
<span id="cb107-71"><a href="#cb107-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-72"><a href="#cb107-72" aria-hidden="true" tabindex="-1"></a><span class="co">// Create a ring buffer.  After creating, be sure to free the memory</span></span>
<span id="cb107-73"><a href="#cb107-73" aria-hidden="true" tabindex="-1"></a><span class="co">// with `ring_buffer_destroy`.</span></span>
<span id="cb107-74"><a href="#cb107-74" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-75"><a href="#cb107-75" aria-hidden="true" tabindex="-1"></a><span class="co">//   size: (maximum) number of elements that the ring buffer may contain</span></span>
<span id="cb107-76"><a href="#cb107-76" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-77"><a href="#cb107-77" aria-hidden="true" tabindex="-1"></a><span class="co">//   stride: number of *bytes* per ring buffer element</span></span>
<span id="cb107-78"><a href="#cb107-78" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-79"><a href="#cb107-79" aria-hidden="true" tabindex="-1"></a><span class="co">// See the note above the struct for details on size/stride.</span></span>
<span id="cb107-80"><a href="#cb107-80" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-81"><a href="#cb107-81" aria-hidden="true" tabindex="-1"></a><span class="co">// If the buffer cannot be allocated (e.g., too big a buffer is</span></span>
<span id="cb107-82"><a href="#cb107-82" aria-hidden="true" tabindex="-1"></a><span class="co">// requested) then an R error will be thrown as this uses `Calloc`.</span></span>
<span id="cb107-83"><a href="#cb107-83" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-84"><a href="#cb107-84" aria-hidden="true" tabindex="-1"></a><span class="co">// This may not always be desirable (e.g., if using from within C++,</span></span>
<span id="cb107-85"><a href="#cb107-85" aria-hidden="true" tabindex="-1"></a><span class="co">// or in a project that does not actually use R).  To use plain C</span></span>
<span id="cb107-86"><a href="#cb107-86" aria-hidden="true" tabindex="-1"></a><span class="co">// stdlib calloc/free, in the ring.c use:</span></span>
<span id="cb107-87"><a href="#cb107-87" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-88"><a href="#cb107-88" aria-hidden="true" tabindex="-1"></a><span class="co">//     #define RING_USE_STDLIB_ALLOC 1</span></span>
<span id="cb107-89"><a href="#cb107-89" aria-hidden="true" tabindex="-1"></a><span class="co">//     #include &lt;ring/ring.c&gt;</span></span>
<span id="cb107-90"><a href="#cb107-90" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-91"><a href="#cb107-91" aria-hidden="true" tabindex="-1"></a><span class="co">// which will not depend on *any* R code and use stdlib calloc/free</span></span>
<span id="cb107-92"><a href="#cb107-92" aria-hidden="true" tabindex="-1"></a><span class="co">// (except for the issue with USING_R/OVERFLOW_ERROR above).  With</span></span>
<span id="cb107-93"><a href="#cb107-93" aria-hidden="true" tabindex="-1"></a><span class="co">// RING_USE_STDLIB_ALLOC defined, if an allocation fails, then</span></span>
<span id="cb107-94"><a href="#cb107-94" aria-hidden="true" tabindex="-1"></a><span class="co">// ring_buffer_create (and ring_buffer_duplicate below) will return</span></span>
<span id="cb107-95"><a href="#cb107-95" aria-hidden="true" tabindex="-1"></a><span class="co">// NULL.  So if using this approach be sure to check the return value!</span></span>
<span id="cb107-96"><a href="#cb107-96" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-97"><a href="#cb107-97" aria-hidden="true" tabindex="-1"></a><span class="co">// The main wrinkle to using RING_USE_STDLIB_ALLOC 1 is that the</span></span>
<span id="cb107-98"><a href="#cb107-98" aria-hidden="true" tabindex="-1"></a><span class="co">// `overflow_action` `OVERFLOW_ERROR` will not work.  At present this</span></span>
<span id="cb107-99"><a href="#cb107-99" aria-hidden="true" tabindex="-1"></a><span class="co">// will fail to compile, but in future I may add an error handler.</span></span>
<span id="cb107-100"><a href="#cb107-100" aria-hidden="true" tabindex="-1"></a>ring_buffer <span class="op">*</span> ring_buffer_create<span class="op">(</span><span class="dt">size_t</span> size<span class="op">,</span> <span class="dt">size_t</span> stride<span class="op">,</span></span>
<span id="cb107-101"><a href="#cb107-101" aria-hidden="true" tabindex="-1"></a>                                 overflow_action on_overflow<span class="op">);</span></span>
<span id="cb107-102"><a href="#cb107-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-103"><a href="#cb107-103" aria-hidden="true" tabindex="-1"></a><span class="co">// Destroy a ring buffer.  Frees the memory</span></span>
<span id="cb107-104"><a href="#cb107-104" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-105"><a href="#cb107-105" aria-hidden="true" tabindex="-1"></a><span class="co">//   buffer: the ring buffer to copy; after calling this function all</span></span>
<span id="cb107-106"><a href="#cb107-106" aria-hidden="true" tabindex="-1"></a><span class="co">//           memory associated with the buffer is freed.</span></span>
<span id="cb107-107"><a href="#cb107-107" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> ring_buffer_destroy<span class="op">(</span>ring_buffer <span class="op">*</span>buffer<span class="op">);</span></span>
<span id="cb107-108"><a href="#cb107-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-109"><a href="#cb107-109" aria-hidden="true" tabindex="-1"></a><span class="co">// Duplicate (copy) a ring buffer.  Copies both the underlying data and</span></span>
<span id="cb107-110"><a href="#cb107-110" aria-hidden="true" tabindex="-1"></a><span class="co">// the position of the head and tail.  A new buffer will be allocated</span></span>
<span id="cb107-111"><a href="#cb107-111" aria-hidden="true" tabindex="-1"></a><span class="co">// and must be freed when finished with, using `ring_buffer_destroy`</span></span>
<span id="cb107-112"><a href="#cb107-112" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-113"><a href="#cb107-113" aria-hidden="true" tabindex="-1"></a><span class="co">//   buffer: a ring buffer to copy from; will not be modified</span></span>
<span id="cb107-114"><a href="#cb107-114" aria-hidden="true" tabindex="-1"></a>ring_buffer <span class="op">*</span> ring_buffer_duplicate<span class="op">(</span><span class="dt">const</span> ring_buffer <span class="op">*</span>buffer<span class="op">);</span></span>
<span id="cb107-115"><a href="#cb107-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-116"><a href="#cb107-116" aria-hidden="true" tabindex="-1"></a><span class="co">// Increase the size of the ring buffer so that it can hold additional</span></span>
<span id="cb107-117"><a href="#cb107-117" aria-hidden="true" tabindex="-1"></a><span class="co">// elements.  This does not alter existing elements but increases the</span></span>
<span id="cb107-118"><a href="#cb107-118" aria-hidden="true" tabindex="-1"></a><span class="co">// capacity (similar to he `reserve` method in the C++ standard</span></span>
<span id="cb107-119"><a href="#cb107-119" aria-hidden="true" tabindex="-1"></a><span class="co">// library).</span></span>
<span id="cb107-120"><a href="#cb107-120" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-121"><a href="#cb107-121" aria-hidden="true" tabindex="-1"></a><span class="co">//   buffer: a ring buffer to increase the size of</span></span>
<span id="cb107-122"><a href="#cb107-122" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-123"><a href="#cb107-123" aria-hidden="true" tabindex="-1"></a><span class="co">//   n: the number of elements to increase the buffer by</span></span>
<span id="cb107-124"><a href="#cb107-124" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-125"><a href="#cb107-125" aria-hidden="true" tabindex="-1"></a><span class="co">//   exact: boolean, indicating if the buffer should be increased by</span></span>
<span id="cb107-126"><a href="#cb107-126" aria-hidden="true" tabindex="-1"></a><span class="co">//          exactly `n` elements (if true) or by at least `n` elements</span></span>
<span id="cb107-127"><a href="#cb107-127" aria-hidden="true" tabindex="-1"></a><span class="co">//          (if false).  If using the inexact method, the buffer is</span></span>
<span id="cb107-128"><a href="#cb107-128" aria-hidden="true" tabindex="-1"></a><span class="co">//          increased in size using geometric growth using the golden</span></span>
<span id="cb107-129"><a href="#cb107-129" aria-hidden="true" tabindex="-1"></a><span class="co">//          ratio.</span></span>
<span id="cb107-130"><a href="#cb107-130" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-131"><a href="#cb107-131" aria-hidden="true" tabindex="-1"></a><span class="co">// After using this function, all references to the head or tail are</span></span>
<span id="cb107-132"><a href="#cb107-132" aria-hidden="true" tabindex="-1"></a><span class="co">// broken and the memory may have been freed and the contents moved</span></span>
<span id="cb107-133"><a href="#cb107-133" aria-hidden="true" tabindex="-1"></a><span class="co">// elsewhere.</span></span>
<span id="cb107-134"><a href="#cb107-134" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-135"><a href="#cb107-135" aria-hidden="true" tabindex="-1"></a><span class="co">// If RING_USE_STDLIB_ALLOC is defined, and if an allocation fails,</span></span>
<span id="cb107-136"><a href="#cb107-136" aria-hidden="true" tabindex="-1"></a><span class="co">// then this may leave things in an undesirable state (this is</span></span>
<span id="cb107-137"><a href="#cb107-137" aria-hidden="true" tabindex="-1"></a><span class="co">// particularly a problem when using on_overflow = OVERFLOW_GROW).</span></span>
<span id="cb107-138"><a href="#cb107-138" aria-hidden="true" tabindex="-1"></a><span class="co">// Currently, if R is used an R error will be thrown (possibly not a</span></span>
<span id="cb107-139"><a href="#cb107-139" aria-hidden="true" tabindex="-1"></a><span class="co">// good idea if running under Rcpp) and if running as a standalone</span></span>
<span id="cb107-140"><a href="#cb107-140" aria-hidden="true" tabindex="-1"></a><span class="co">// application then the data will be set to NULL, probably causing a</span></span>
<span id="cb107-141"><a href="#cb107-141" aria-hidden="true" tabindex="-1"></a><span class="co">// crash pretty quickly (improvements welcome).</span></span>
<span id="cb107-142"><a href="#cb107-142" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> ring_buffer_grow<span class="op">(</span>ring_buffer <span class="op">*</span>buffer<span class="op">,</span> <span class="dt">size_t</span> n<span class="op">,</span> <span class="dt">bool</span> exact<span class="op">);</span></span>
<span id="cb107-143"><a href="#cb107-143" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-144"><a href="#cb107-144" aria-hidden="true" tabindex="-1"></a><span class="co">// Reset the state of the buffer.  This "zeros" the head and tail</span></span>
<span id="cb107-145"><a href="#cb107-145" aria-hidden="true" tabindex="-1"></a><span class="co">// pointer (and may or may not actually reset the data) so that the</span></span>
<span id="cb107-146"><a href="#cb107-146" aria-hidden="true" tabindex="-1"></a><span class="co">// buffer can be used as if fresh.</span></span>
<span id="cb107-147"><a href="#cb107-147" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-148"><a href="#cb107-148" aria-hidden="true" tabindex="-1"></a><span class="co">//   buffer: a ring buffer to reset</span></span>
<span id="cb107-149"><a href="#cb107-149" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-150"><a href="#cb107-150" aria-hidden="true" tabindex="-1"></a><span class="co">//   clear: boolean, indicating if memory should also be zeroed</span></span>
<span id="cb107-151"><a href="#cb107-151" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> ring_buffer_reset<span class="op">(</span>ring_buffer <span class="op">*</span>buffer<span class="op">,</span> <span class="dt">bool</span> clear<span class="op">);</span></span>
<span id="cb107-152"><a href="#cb107-152" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-153"><a href="#cb107-153" aria-hidden="true" tabindex="-1"></a><span class="co">//// Basic querying: ////</span></span>
<span id="cb107-154"><a href="#cb107-154" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-155"><a href="#cb107-155" aria-hidden="true" tabindex="-1"></a><span class="co">// Return the maximum size of the ring buffer</span></span>
<span id="cb107-156"><a href="#cb107-156" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-157"><a href="#cb107-157" aria-hidden="true" tabindex="-1"></a><span class="co">//   buffer: the ring buffer to test (will not be modified)</span></span>
<span id="cb107-158"><a href="#cb107-158" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-159"><a href="#cb107-159" aria-hidden="true" tabindex="-1"></a><span class="co">//   bytes: indicates if size should be in bytes (if true) or elements</span></span>
<span id="cb107-160"><a href="#cb107-160" aria-hidden="true" tabindex="-1"></a><span class="co">//          (if false)</span></span>
<span id="cb107-161"><a href="#cb107-161" aria-hidden="true" tabindex="-1"></a><span class="dt">size_t</span> ring_buffer_size<span class="op">(</span><span class="dt">const</span> ring_buffer <span class="op">*</span>buffer<span class="op">,</span> <span class="dt">bool</span> bytes<span class="op">);</span></span>
<span id="cb107-162"><a href="#cb107-162" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-163"><a href="#cb107-163" aria-hidden="true" tabindex="-1"></a><span class="co">// Report the free and used space in the ring buffer</span></span>
<span id="cb107-164"><a href="#cb107-164" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-165"><a href="#cb107-165" aria-hidden="true" tabindex="-1"></a><span class="co">//   buffer: the ring buffer to test (will not be modified)</span></span>
<span id="cb107-166"><a href="#cb107-166" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-167"><a href="#cb107-167" aria-hidden="true" tabindex="-1"></a><span class="co">//   bytes: indicates if used/free space should be in bytes (if true)</span></span>
<span id="cb107-168"><a href="#cb107-168" aria-hidden="true" tabindex="-1"></a><span class="co">//          or elements (if false)</span></span>
<span id="cb107-169"><a href="#cb107-169" aria-hidden="true" tabindex="-1"></a><span class="dt">size_t</span> ring_buffer_free<span class="op">(</span><span class="dt">const</span> ring_buffer <span class="op">*</span>buffer<span class="op">,</span> <span class="dt">bool</span> bytes<span class="op">);</span></span>
<span id="cb107-170"><a href="#cb107-170" aria-hidden="true" tabindex="-1"></a><span class="dt">size_t</span> ring_buffer_used<span class="op">(</span><span class="dt">const</span> ring_buffer <span class="op">*</span>buffer<span class="op">,</span> <span class="dt">bool</span> bytes<span class="op">);</span></span>
<span id="cb107-171"><a href="#cb107-171" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-172"><a href="#cb107-172" aria-hidden="true" tabindex="-1"></a><span class="co">// Report the number of bytes of data that have been allocated.  Note</span></span>
<span id="cb107-173"><a href="#cb107-173" aria-hidden="true" tabindex="-1"></a><span class="co">// that this is likely `stride` more bytes than was requested as this</span></span>
<span id="cb107-174"><a href="#cb107-174" aria-hidden="true" tabindex="-1"></a><span class="co">// avoids a lot of awkward bookkeeping later, allowing the "full"</span></span>
<span id="cb107-175"><a href="#cb107-175" aria-hidden="true" tabindex="-1"></a><span class="co">// state to be distinguished from the "empty" state.</span></span>
<span id="cb107-176"><a href="#cb107-176" aria-hidden="true" tabindex="-1"></a><span class="dt">size_t</span> ring_buffer_bytes_data<span class="op">(</span><span class="dt">const</span> ring_buffer <span class="op">*</span>buffer<span class="op">);</span></span>
<span id="cb107-177"><a href="#cb107-177" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-178"><a href="#cb107-178" aria-hidden="true" tabindex="-1"></a><span class="co">// Report if the ring buffer is full or empty</span></span>
<span id="cb107-179"><a href="#cb107-179" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> ring_buffer_is_full<span class="op">(</span><span class="dt">const</span> ring_buffer <span class="op">*</span>buffer<span class="op">);</span></span>
<span id="cb107-180"><a href="#cb107-180" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> ring_buffer_is_empty<span class="op">(</span><span class="dt">const</span> ring_buffer <span class="op">*</span>buffer<span class="op">);</span></span>
<span id="cb107-181"><a href="#cb107-181" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-182"><a href="#cb107-182" aria-hidden="true" tabindex="-1"></a><span class="co">//// Additional querying: ////</span></span>
<span id="cb107-183"><a href="#cb107-183" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-184"><a href="#cb107-184" aria-hidden="true" tabindex="-1"></a><span class="co">// Return the position of the head and tail pointers relative to the</span></span>
<span id="cb107-185"><a href="#cb107-185" aria-hidden="true" tabindex="-1"></a><span class="co">// data pointer (this is an offset, so 0 means the pointer is at the</span></span>
<span id="cb107-186"><a href="#cb107-186" aria-hidden="true" tabindex="-1"></a><span class="co">// start of the data array).</span></span>
<span id="cb107-187"><a href="#cb107-187" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-188"><a href="#cb107-188" aria-hidden="true" tabindex="-1"></a><span class="co">//   bytes: indicates if offset should be bytes (if true) or elements (if false)</span></span>
<span id="cb107-189"><a href="#cb107-189" aria-hidden="true" tabindex="-1"></a><span class="dt">size_t</span> ring_buffer_head_pos<span class="op">(</span><span class="dt">const</span> ring_buffer <span class="op">*</span>buffer<span class="op">,</span> <span class="dt">bool</span> bytes<span class="op">);</span></span>
<span id="cb107-190"><a href="#cb107-190" aria-hidden="true" tabindex="-1"></a><span class="dt">size_t</span> ring_buffer_tail_pos<span class="op">(</span><span class="dt">const</span> ring_buffer <span class="op">*</span>buffer<span class="op">,</span> <span class="dt">bool</span> bytes<span class="op">);</span></span>
<span id="cb107-191"><a href="#cb107-191" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-192"><a href="#cb107-192" aria-hidden="true" tabindex="-1"></a><span class="co">// Return pointers to the the data, head and tail members of the ring</span></span>
<span id="cb107-193"><a href="#cb107-193" aria-hidden="true" tabindex="-1"></a><span class="co">// buffer.  These are preferred over directly accessing the "data",</span></span>
<span id="cb107-194"><a href="#cb107-194" aria-hidden="true" tabindex="-1"></a><span class="co">// "head" and "tail" elements of the ring buffer structure itself</span></span>
<span id="cb107-195"><a href="#cb107-195" aria-hidden="true" tabindex="-1"></a><span class="co">// because with these the compiler will enforce read-only access for</span></span>
<span id="cb107-196"><a href="#cb107-196" aria-hidden="true" tabindex="-1"></a><span class="co">// you.</span></span>
<span id="cb107-197"><a href="#cb107-197" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-198"><a href="#cb107-198" aria-hidden="true" tabindex="-1"></a><span class="co">// </span><span class="al">WARNING</span><span class="co">: the head buffer is *not* the most recently added element,</span></span>
<span id="cb107-199"><a href="#cb107-199" aria-hidden="true" tabindex="-1"></a><span class="co">// but instead the bit of memory that will be written to next; it's</span></span>
<span id="cb107-200"><a href="#cb107-200" aria-hidden="true" tabindex="-1"></a><span class="co">// generally not terribly useful and a better way of getting the last</span></span>
<span id="cb107-201"><a href="#cb107-201" aria-hidden="true" tabindex="-1"></a><span class="co">// written element is to use:</span></span>
<span id="cb107-202"><a href="#cb107-202" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-203"><a href="#cb107-203" aria-hidden="true" tabindex="-1"></a><span class="co">//   ring_buffer_head_offset(buffer, 0);</span></span>
<span id="cb107-204"><a href="#cb107-204" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-205"><a href="#cb107-205" aria-hidden="true" tabindex="-1"></a><span class="co">// which will look after wrapping the ring buffer appropriately.</span></span>
<span id="cb107-206"><a href="#cb107-206" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">void</span> <span class="op">*</span> ring_buffer_data<span class="op">(</span><span class="dt">const</span> ring_buffer <span class="op">*</span>buffer<span class="op">);</span></span>
<span id="cb107-207"><a href="#cb107-207" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">void</span> <span class="op">*</span> ring_buffer_head<span class="op">(</span><span class="dt">const</span> ring_buffer <span class="op">*</span>buffer<span class="op">);</span></span>
<span id="cb107-208"><a href="#cb107-208" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">void</span> <span class="op">*</span> ring_buffer_tail<span class="op">(</span><span class="dt">const</span> ring_buffer <span class="op">*</span>buffer<span class="op">);</span></span>
<span id="cb107-209"><a href="#cb107-209" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-210"><a href="#cb107-210" aria-hidden="true" tabindex="-1"></a><span class="co">//// Setting repeated values: ////</span></span>
<span id="cb107-211"><a href="#cb107-211" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-212"><a href="#cb107-212" aria-hidden="true" tabindex="-1"></a><span class="co">// Set all bytes of a length of the buffer to 'c'.  Here, 'len' is the</span></span>
<span id="cb107-213"><a href="#cb107-213" aria-hidden="true" tabindex="-1"></a><span class="co">// number of *entries*, so stride * len bytes will be set.  This will</span></span>
<span id="cb107-214"><a href="#cb107-214" aria-hidden="true" tabindex="-1"></a><span class="co">// mostly be uesful with c=0.</span></span>
<span id="cb107-215"><a href="#cb107-215" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-216"><a href="#cb107-216" aria-hidden="true" tabindex="-1"></a><span class="co">//   buffer: the ring buffer to set data into</span></span>
<span id="cb107-217"><a href="#cb107-217" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-218"><a href="#cb107-218" aria-hidden="true" tabindex="-1"></a><span class="co">//   c: value (0-255) to set all bytes to</span></span>
<span id="cb107-219"><a href="#cb107-219" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-220"><a href="#cb107-220" aria-hidden="true" tabindex="-1"></a><span class="co">//   n: number of elements to set</span></span>
<span id="cb107-221"><a href="#cb107-221" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-222"><a href="#cb107-222" aria-hidden="true" tabindex="-1"></a><span class="co">// This starts adding data at `head`.  If the buffer will overflow, at</span></span>
<span id="cb107-223"><a href="#cb107-223" aria-hidden="true" tabindex="-1"></a><span class="co">// most `bytes_data` bytes will be written (i.e., each element will be</span></span>
<span id="cb107-224"><a href="#cb107-224" aria-hidden="true" tabindex="-1"></a><span class="co">// written to once).</span></span>
<span id="cb107-225"><a href="#cb107-225" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-226"><a href="#cb107-226" aria-hidden="true" tabindex="-1"></a><span class="co">// Returns the number of bytes actually written to the buffer (so if</span></span>
<span id="cb107-227"><a href="#cb107-227" aria-hidden="true" tabindex="-1"></a><span class="co">// the buffer overflows this may be less than `len`).</span></span>
<span id="cb107-228"><a href="#cb107-228" aria-hidden="true" tabindex="-1"></a><span class="dt">size_t</span> ring_buffer_set<span class="op">(</span>ring_buffer <span class="op">*</span>buffer<span class="op">,</span> data_t c<span class="op">,</span> <span class="dt">size_t</span> n<span class="op">);</span></span>
<span id="cb107-229"><a href="#cb107-229" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-230"><a href="#cb107-230" aria-hidden="true" tabindex="-1"></a><span class="co">// Set a number of the elements of the buffer to a particular byte</span></span>
<span id="cb107-231"><a href="#cb107-231" aria-hidden="true" tabindex="-1"></a><span class="co">// pattern.  In contrast with `ring_buffer_set`, this does not set</span></span>
<span id="cb107-232"><a href="#cb107-232" aria-hidden="true" tabindex="-1"></a><span class="co">// individual bytes, but instead complete elements.</span></span>
<span id="cb107-233"><a href="#cb107-233" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-234"><a href="#cb107-234" aria-hidden="true" tabindex="-1"></a><span class="co">//    buffer: the ring buffer to set data into</span></span>
<span id="cb107-235"><a href="#cb107-235" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-236"><a href="#cb107-236" aria-hidden="true" tabindex="-1"></a><span class="co">//    x: pointer to a set of data to copy into the ring buffer.  This</span></span>
<span id="cb107-237"><a href="#cb107-237" aria-hidden="true" tabindex="-1"></a><span class="co">//            must be (at least) stride bytes long.</span></span>
<span id="cb107-238"><a href="#cb107-238" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-239"><a href="#cb107-239" aria-hidden="true" tabindex="-1"></a><span class="co">//    n: number of elements to set</span></span>
<span id="cb107-240"><a href="#cb107-240" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-241"><a href="#cb107-241" aria-hidden="true" tabindex="-1"></a><span class="co">// This starts adding data at `head`.  If the buffer will overflow, at</span></span>
<span id="cb107-242"><a href="#cb107-242" aria-hidden="true" tabindex="-1"></a><span class="co">// most `bytes_data` bytes will be written (i.e., each element will be</span></span>
<span id="cb107-243"><a href="#cb107-243" aria-hidden="true" tabindex="-1"></a><span class="co">// written to once).</span></span>
<span id="cb107-244"><a href="#cb107-244" aria-hidden="true" tabindex="-1"></a><span class="dt">size_t</span> ring_buffer_set_stride<span class="op">(</span>ring_buffer <span class="op">*</span>buffer<span class="op">,</span> <span class="dt">const</span> <span class="dt">void</span> <span class="op">*</span>x<span class="op">,</span> <span class="dt">size_t</span> n<span class="op">);</span></span>
<span id="cb107-245"><a href="#cb107-245" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-246"><a href="#cb107-246" aria-hidden="true" tabindex="-1"></a><span class="co">//// Read and write ////</span></span>
<span id="cb107-247"><a href="#cb107-247" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-248"><a href="#cb107-248" aria-hidden="true" tabindex="-1"></a><span class="co">// Copy `n` entries, each of `stride` bytes from a contiguous memory</span></span>
<span id="cb107-249"><a href="#cb107-249" aria-hidden="true" tabindex="-1"></a><span class="co">// area src into the ring `buffer`. Returns the ring buffer's new head</span></span>
<span id="cb107-250"><a href="#cb107-250" aria-hidden="true" tabindex="-1"></a><span class="co">// pointer.</span></span>
<span id="cb107-251"><a href="#cb107-251" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-252"><a href="#cb107-252" aria-hidden="true" tabindex="-1"></a><span class="co">// It is possible to overflow the buffer with this function</span></span>
<span id="cb107-253"><a href="#cb107-253" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-254"><a href="#cb107-254" aria-hidden="true" tabindex="-1"></a><span class="co">//   buffer: the ring buffer to copy data into</span></span>
<span id="cb107-255"><a href="#cb107-255" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-256"><a href="#cb107-256" aria-hidden="true" tabindex="-1"></a><span class="co">//   src: the source memory to copy from (make sure this is big enough</span></span>
<span id="cb107-257"><a href="#cb107-257" aria-hidden="true" tabindex="-1"></a><span class="co">//           or you will get crashes and other terrible things).</span></span>
<span id="cb107-258"><a href="#cb107-258" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-259"><a href="#cb107-259" aria-hidden="true" tabindex="-1"></a><span class="co">//   n: the number of entries to copy from `src` into `buffer` (each</span></span>
<span id="cb107-260"><a href="#cb107-260" aria-hidden="true" tabindex="-1"></a><span class="co">//           of which is `stride` bytes long).</span></span>
<span id="cb107-261"><a href="#cb107-261" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">void</span> <span class="op">*</span> ring_buffer_push<span class="op">(</span>ring_buffer <span class="op">*</span>buffer<span class="op">,</span> <span class="dt">const</span> <span class="dt">void</span> <span class="op">*</span>src<span class="op">,</span> <span class="dt">size_t</span> n<span class="op">);</span></span>
<span id="cb107-262"><a href="#cb107-262" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-263"><a href="#cb107-263" aria-hidden="true" tabindex="-1"></a><span class="co">// Destructively copy `n` entries (each of which is `stride` bytes)</span></span>
<span id="cb107-264"><a href="#cb107-264" aria-hidden="true" tabindex="-1"></a><span class="co">// from a ring buffer `buffer` into contiguous memory region `dest`.</span></span>
<span id="cb107-265"><a href="#cb107-265" aria-hidden="true" tabindex="-1"></a><span class="co">// This updates the `tail` pointers in the ring buffer and returns the</span></span>
<span id="cb107-266"><a href="#cb107-266" aria-hidden="true" tabindex="-1"></a><span class="co">// new tail pointer.</span></span>
<span id="cb107-267"><a href="#cb107-267" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-268"><a href="#cb107-268" aria-hidden="true" tabindex="-1"></a><span class="co">// The `n` entries will no longer be available in the ring buffer.</span></span>
<span id="cb107-269"><a href="#cb107-269" aria-hidden="true" tabindex="-1"></a><span class="co">// To do a nondestructive read, use `ring_buffer_read()`.</span></span>
<span id="cb107-270"><a href="#cb107-270" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-271"><a href="#cb107-271" aria-hidden="true" tabindex="-1"></a><span class="co">//   buffer: the ring buffer to copy data from</span></span>
<span id="cb107-272"><a href="#cb107-272" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-273"><a href="#cb107-273" aria-hidden="true" tabindex="-1"></a><span class="co">//   dest: the destination memory to copy into (make sure this is big enough</span></span>
<span id="cb107-274"><a href="#cb107-274" aria-hidden="true" tabindex="-1"></a><span class="co">//           or you will get crashes and other terrible things).</span></span>
<span id="cb107-275"><a href="#cb107-275" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-276"><a href="#cb107-276" aria-hidden="true" tabindex="-1"></a><span class="co">//   n: the number of entries to copy from `src` into `buffer` (each</span></span>
<span id="cb107-277"><a href="#cb107-277" aria-hidden="true" tabindex="-1"></a><span class="co">//           of which is `stride` bytes long).</span></span>
<span id="cb107-278"><a href="#cb107-278" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-279"><a href="#cb107-279" aria-hidden="true" tabindex="-1"></a><span class="co">// This function will not allow the ring buffer to underflow.  If</span></span>
<span id="cb107-280"><a href="#cb107-280" aria-hidden="true" tabindex="-1"></a><span class="co">// `n` is greater than the number of available entries, then</span></span>
<span id="cb107-281"><a href="#cb107-281" aria-hidden="true" tabindex="-1"></a><span class="co">// nothing is copied (and the ring buffer remains unmodified) and NULL</span></span>
<span id="cb107-282"><a href="#cb107-282" aria-hidden="true" tabindex="-1"></a><span class="co">// is returned.</span></span>
<span id="cb107-283"><a href="#cb107-283" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">void</span> <span class="op">*</span> ring_buffer_take<span class="op">(</span>ring_buffer <span class="op">*</span>buffer<span class="op">,</span> <span class="dt">void</span> <span class="op">*</span>dest<span class="op">,</span> <span class="dt">size_t</span> n<span class="op">);</span></span>
<span id="cb107-284"><a href="#cb107-284" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-285"><a href="#cb107-285" aria-hidden="true" tabindex="-1"></a><span class="co">// Nondestructively read from a ring buffer.  This function is</span></span>
<span id="cb107-286"><a href="#cb107-286" aria-hidden="true" tabindex="-1"></a><span class="co">// essentially identical to `ring_buffer_take` but does not alter the</span></span>
<span id="cb107-287"><a href="#cb107-287" aria-hidden="true" tabindex="-1"></a><span class="co">// tail pointer.</span></span>
<span id="cb107-288"><a href="#cb107-288" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">void</span> <span class="op">*</span> ring_buffer_read<span class="op">(</span><span class="dt">const</span> ring_buffer <span class="op">*</span>buffer<span class="op">,</span> <span class="dt">void</span> <span class="op">*</span>dest<span class="op">,</span> <span class="dt">size_t</span> n<span class="op">);</span></span>
<span id="cb107-289"><a href="#cb107-289" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-290"><a href="#cb107-290" aria-hidden="true" tabindex="-1"></a><span class="co">// ring_buffer_take_head and ring_buffer_read_head are like</span></span>
<span id="cb107-291"><a href="#cb107-291" aria-hidden="true" tabindex="-1"></a><span class="co">// ring_buffer_take and ring_buffer_read (respectively) but operate on</span></span>
<span id="cb107-292"><a href="#cb107-292" aria-hidden="true" tabindex="-1"></a><span class="co">// the *head* of the ring (i.e., removing the most recently added</span></span>
<span id="cb107-293"><a href="#cb107-293" aria-hidden="true" tabindex="-1"></a><span class="co">// elements rather than the oldest elements).</span></span>
<span id="cb107-294"><a href="#cb107-294" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-295"><a href="#cb107-295" aria-hidden="true" tabindex="-1"></a><span class="co">// Neither will underflow, returning NULL if there are not enough</span></span>
<span id="cb107-296"><a href="#cb107-296" aria-hidden="true" tabindex="-1"></a><span class="co">// elements, and without copying anything.</span></span>
<span id="cb107-297"><a href="#cb107-297" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">void</span> <span class="op">*</span> ring_buffer_take_head<span class="op">(</span>ring_buffer <span class="op">*</span>buffer<span class="op">,</span> <span class="dt">void</span> <span class="op">*</span>dest<span class="op">,</span> <span class="dt">size_t</span> n<span class="op">);</span></span>
<span id="cb107-298"><a href="#cb107-298" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">void</span> <span class="op">*</span> ring_buffer_read_head<span class="op">(</span><span class="dt">const</span> ring_buffer <span class="op">*</span>buffer<span class="op">,</span> <span class="dt">void</span> <span class="op">*</span>dest<span class="op">,</span></span>
<span id="cb107-299"><a href="#cb107-299" aria-hidden="true" tabindex="-1"></a>                                   <span class="dt">size_t</span> n<span class="op">);</span></span>
<span id="cb107-300"><a href="#cb107-300" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-301"><a href="#cb107-301" aria-hidden="true" tabindex="-1"></a><span class="co">// Copy `n` entries (each of `stride` bytes) from one ring buffer</span></span>
<span id="cb107-302"><a href="#cb107-302" aria-hidden="true" tabindex="-1"></a><span class="co">// `src` into another `dest`.  The copy starts at the tail of this</span></span>
<span id="cb107-303"><a href="#cb107-303" aria-hidden="true" tabindex="-1"></a><span class="co">// ring buffer, pushing onto the head of the destination buffer.</span></span>
<span id="cb107-304"><a href="#cb107-304" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-305"><a href="#cb107-305" aria-hidden="true" tabindex="-1"></a><span class="co">//   src: A ring buffer to copy data from</span></span>
<span id="cb107-306"><a href="#cb107-306" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-307"><a href="#cb107-307" aria-hidden="true" tabindex="-1"></a><span class="co">//   dest: A ring buffer to copy data into</span></span>
<span id="cb107-308"><a href="#cb107-308" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-309"><a href="#cb107-309" aria-hidden="true" tabindex="-1"></a><span class="co">//   n: the number of entries to copy (each of which is `stride` bytes)</span></span>
<span id="cb107-310"><a href="#cb107-310" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-311"><a href="#cb107-311" aria-hidden="true" tabindex="-1"></a><span class="co">// This is destructive to both buffers as pointers will be updated in</span></span>
<span id="cb107-312"><a href="#cb107-312" aria-hidden="true" tabindex="-1"></a><span class="co">// both.</span></span>
<span id="cb107-313"><a href="#cb107-313" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-314"><a href="#cb107-314" aria-hidden="true" tabindex="-1"></a><span class="co">// This function returns the new head pointer of the destination buffer.</span></span>
<span id="cb107-315"><a href="#cb107-315" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-316"><a href="#cb107-316" aria-hidden="true" tabindex="-1"></a><span class="co">// It is not possible to underflow `src`; if too few entries are</span></span>
<span id="cb107-317"><a href="#cb107-317" aria-hidden="true" tabindex="-1"></a><span class="co">// available, then nothing is copied, `src` and `dest` are not</span></span>
<span id="cb107-318"><a href="#cb107-318" aria-hidden="true" tabindex="-1"></a><span class="co">// modified, and the function returns NULL</span></span>
<span id="cb107-319"><a href="#cb107-319" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-320"><a href="#cb107-320" aria-hidden="true" tabindex="-1"></a><span class="co">// It is possible to overflow `dest` and the tail pointer will be</span></span>
<span id="cb107-321"><a href="#cb107-321" aria-hidden="true" tabindex="-1"></a><span class="co">// updated appropriately if so.</span></span>
<span id="cb107-322"><a href="#cb107-322" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-323"><a href="#cb107-323" aria-hidden="true" tabindex="-1"></a><span class="co">// Warning: the two buffers must have the same stride.  If the buffers</span></span>
<span id="cb107-324"><a href="#cb107-324" aria-hidden="true" tabindex="-1"></a><span class="co">// do not have the same stride, the function will return NULL (this</span></span>
<span id="cb107-325"><a href="#cb107-325" aria-hidden="true" tabindex="-1"></a><span class="co">// means if the function returns NULL it could either be an underflow</span></span>
<span id="cb107-326"><a href="#cb107-326" aria-hidden="true" tabindex="-1"></a><span class="co">// or an incompatible buffer).</span></span>
<span id="cb107-327"><a href="#cb107-327" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">void</span> <span class="op">*</span> ring_buffer_copy<span class="op">(</span>ring_buffer <span class="op">*</span>src<span class="op">,</span> ring_buffer <span class="op">*</span>dest<span class="op">,</span> <span class="dt">size_t</span> n<span class="op">);</span></span>
<span id="cb107-328"><a href="#cb107-328" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-329"><a href="#cb107-329" aria-hidden="true" tabindex="-1"></a><span class="co">// Mirror the contents of ring buffer `src` into ring buffer `dest`.</span></span>
<span id="cb107-330"><a href="#cb107-330" aria-hidden="true" tabindex="-1"></a><span class="co">// This differs from `ring_buffer_copy` in that the `src` buffer is</span></span>
<span id="cb107-331"><a href="#cb107-331" aria-hidden="true" tabindex="-1"></a><span class="co">// not modified and that the *entire* state of the ring buffer is</span></span>
<span id="cb107-332"><a href="#cb107-332" aria-hidden="true" tabindex="-1"></a><span class="co">// duplicated.</span></span>
<span id="cb107-333"><a href="#cb107-333" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-334"><a href="#cb107-334" aria-hidden="true" tabindex="-1"></a><span class="co">// The function requires (and checks) that `src` and `dest` agree on</span></span>
<span id="cb107-335"><a href="#cb107-335" aria-hidden="true" tabindex="-1"></a><span class="co">// size and stride (and therefore total bytes).  It returns `true` if</span></span>
<span id="cb107-336"><a href="#cb107-336" aria-hidden="true" tabindex="-1"></a><span class="co">// the mirror was done, and `false` if the buffers are incompatible.</span></span>
<span id="cb107-337"><a href="#cb107-337" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-338"><a href="#cb107-338" aria-hidden="true" tabindex="-1"></a><span class="co">// This function will destroy all data in `dest`, but not allocate any</span></span>
<span id="cb107-339"><a href="#cb107-339" aria-hidden="true" tabindex="-1"></a><span class="co">// memory.</span></span>
<span id="cb107-340"><a href="#cb107-340" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-341"><a href="#cb107-341" aria-hidden="true" tabindex="-1"></a><span class="co">// Warning: the two buffers must have the same stride *and* the same</span></span>
<span id="cb107-342"><a href="#cb107-342" aria-hidden="true" tabindex="-1"></a><span class="co">// size.  If they do not, the function will return NULL (this means if</span></span>
<span id="cb107-343"><a href="#cb107-343" aria-hidden="true" tabindex="-1"></a><span class="co">// the function returns NULL it could either be an underflow or an</span></span>
<span id="cb107-344"><a href="#cb107-344" aria-hidden="true" tabindex="-1"></a><span class="co">// incompatible buffer).</span></span>
<span id="cb107-345"><a href="#cb107-345" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> ring_buffer_mirror<span class="op">(</span><span class="dt">const</span> ring_buffer <span class="op">*</span>src<span class="op">,</span> ring_buffer <span class="op">*</span>dest<span class="op">);</span></span>
<span id="cb107-346"><a href="#cb107-346" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-347"><a href="#cb107-347" aria-hidden="true" tabindex="-1"></a><span class="co">// Returns a pointer to the tail (reading end) of the buffer, offset</span></span>
<span id="cb107-348"><a href="#cb107-348" aria-hidden="true" tabindex="-1"></a><span class="co">// by `offset` entries.  When used as `ring_buffer_tail_offset(x, 0)`</span></span>
<span id="cb107-349"><a href="#cb107-349" aria-hidden="true" tabindex="-1"></a><span class="co">// this is equivalent to `ring_buffer_tail(x)` except that it will do</span></span>
<span id="cb107-350"><a href="#cb107-350" aria-hidden="true" tabindex="-1"></a><span class="co">// underflow checking.</span></span>
<span id="cb107-351"><a href="#cb107-351" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-352"><a href="#cb107-352" aria-hidden="true" tabindex="-1"></a><span class="co">//   buffer: the ring buffer to use</span></span>
<span id="cb107-353"><a href="#cb107-353" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-354"><a href="#cb107-354" aria-hidden="true" tabindex="-1"></a><span class="co">//   offset: the number of entries (each of which are `stride` bytes)</span></span>
<span id="cb107-355"><a href="#cb107-355" aria-hidden="true" tabindex="-1"></a><span class="co">//           to offset by</span></span>
<span id="cb107-356"><a href="#cb107-356" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-357"><a href="#cb107-357" aria-hidden="true" tabindex="-1"></a><span class="co">// It is not possible to underflow the buffer here; if `offset` is so</span></span>
<span id="cb107-358"><a href="#cb107-358" aria-hidden="true" tabindex="-1"></a><span class="co">// large that it would underflow, then NULL will be returned.</span></span>
<span id="cb107-359"><a href="#cb107-359" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">void</span> <span class="op">*</span> ring_buffer_tail_offset<span class="op">(</span><span class="dt">const</span> ring_buffer <span class="op">*</span>buffer<span class="op">,</span> <span class="dt">size_t</span> offset<span class="op">);</span></span>
<span id="cb107-360"><a href="#cb107-360" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-361"><a href="#cb107-361" aria-hidden="true" tabindex="-1"></a><span class="co">// As for `ring_buffer_tail_offset`, but offsetting the *head*</span></span>
<span id="cb107-362"><a href="#cb107-362" aria-hidden="true" tabindex="-1"></a><span class="co">// pointer.  This offsets in the opposite direction (moving from the</span></span>
<span id="cb107-363"><a href="#cb107-363" aria-hidden="true" tabindex="-1"></a><span class="co">// most recently added element towards the oldest element).</span></span>
<span id="cb107-364"><a href="#cb107-364" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">void</span> <span class="op">*</span> ring_buffer_head_offset<span class="op">(</span><span class="dt">const</span> ring_buffer <span class="op">*</span>buffer<span class="op">,</span> <span class="dt">size_t</span> offset<span class="op">);</span></span>
<span id="cb107-365"><a href="#cb107-365" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-366"><a href="#cb107-366" aria-hidden="true" tabindex="-1"></a><span class="co">//// For advanced use: ////</span></span>
<span id="cb107-367"><a href="#cb107-367" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-368"><a href="#cb107-368" aria-hidden="true" tabindex="-1"></a><span class="co">// Advance the ring buffer by one entry and return a pointer to the</span></span>
<span id="cb107-369"><a href="#cb107-369" aria-hidden="true" tabindex="-1"></a><span class="co">// memory *without writing anything to it*.  In this case, the calling</span></span>
<span id="cb107-370"><a href="#cb107-370" aria-hidden="true" tabindex="-1"></a><span class="co">// function is responsible for setting the memory to something</span></span>
<span id="cb107-371"><a href="#cb107-371" aria-hidden="true" tabindex="-1"></a><span class="co">// sensible.  This is currently used in the dde package where we want</span></span>
<span id="cb107-372"><a href="#cb107-372" aria-hidden="true" tabindex="-1"></a><span class="co">// to write directly to the head.</span></span>
<span id="cb107-373"><a href="#cb107-373" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-374"><a href="#cb107-374" aria-hidden="true" tabindex="-1"></a><span class="co">// This is (roughly) equivalent to:</span></span>
<span id="cb107-375"><a href="#cb107-375" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-376"><a href="#cb107-376" aria-hidden="true" tabindex="-1"></a><span class="co">//    ring_buffer_set(buffer, 0, 1);</span></span>
<span id="cb107-377"><a href="#cb107-377" aria-hidden="true" tabindex="-1"></a><span class="co">//    return buffer-&gt;head;</span></span>
<span id="cb107-378"><a href="#cb107-378" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-379"><a href="#cb107-379" aria-hidden="true" tabindex="-1"></a><span class="co">// but does not actually copy any data.</span></span>
<span id="cb107-380"><a href="#cb107-380" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-381"><a href="#cb107-381" aria-hidden="true" tabindex="-1"></a><span class="co">// Note that the pointer returned is *not* const; this is always used</span></span>
<span id="cb107-382"><a href="#cb107-382" aria-hidden="true" tabindex="-1"></a><span class="co">// in a case where the aim is to write to the head directly!</span></span>
<span id="cb107-383"><a href="#cb107-383" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="op">*</span> ring_buffer_head_advance<span class="op">(</span>ring_buffer <span class="op">*</span>buffer<span class="op">);</span></span>
<span id="cb107-384"><a href="#cb107-384" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-385"><a href="#cb107-385" aria-hidden="true" tabindex="-1"></a><span class="co">//// Search: ////</span></span>
<span id="cb107-386"><a href="#cb107-386" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-387"><a href="#cb107-387" aria-hidden="true" tabindex="-1"></a><span class="co">// There are two functions for searching for data within a ring buffer</span></span>
<span id="cb107-388"><a href="#cb107-388" aria-hidden="true" tabindex="-1"></a><span class="co">// that consists of *sorted* entries.  This might be the case if</span></span>
<span id="cb107-389"><a href="#cb107-389" aria-hidden="true" tabindex="-1"></a><span class="co">// entries are added sequentially with (say) a timestamp.</span></span>
<span id="cb107-390"><a href="#cb107-390" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-391"><a href="#cb107-391" aria-hidden="true" tabindex="-1"></a><span class="co">// To locate an entry, a predicate function (pointer) must be</span></span>
<span id="cb107-392"><a href="#cb107-392" aria-hidden="true" tabindex="-1"></a><span class="co">// provided.  This must be a function taking two void pointers as</span></span>
<span id="cb107-393"><a href="#cb107-393" aria-hidden="true" tabindex="-1"></a><span class="co">// arguments; the first will be the pointer to an entry in the ring</span></span>
<span id="cb107-394"><a href="#cb107-394" aria-hidden="true" tabindex="-1"></a><span class="co">// buffer, the second will be any data that *you* provide (may be</span></span>
<span id="cb107-395"><a href="#cb107-395" aria-hidden="true" tabindex="-1"></a><span class="co">// NULL).  This function must return "true" if the value is *less</span></span>
<span id="cb107-396"><a href="#cb107-396" aria-hidden="true" tabindex="-1"></a><span class="co">// than* the target value (i.e. true if we should search *earlier* in</span></span>
<span id="cb107-397"><a href="#cb107-397" aria-hidden="true" tabindex="-1"></a><span class="co">// the buffer).  The "x" argument must be treated as read-only.</span></span>
<span id="cb107-398"><a href="#cb107-398" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-399"><a href="#cb107-399" aria-hidden="true" tabindex="-1"></a><span class="co">// For example, a predictate function that would find an entry where</span></span>
<span id="cb107-400"><a href="#cb107-400" aria-hidden="true" tabindex="-1"></a><span class="co">// the first 8 bytes of a ring buffer entry represent doubles could be</span></span>
<span id="cb107-401"><a href="#cb107-401" aria-hidden="true" tabindex="-1"></a><span class="co">// written as:</span></span>
<span id="cb107-402"><a href="#cb107-402" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-403"><a href="#cb107-403" aria-hidden="true" tabindex="-1"></a><span class="co">//     bool test_find_double(const void *x, void *data) {</span></span>
<span id="cb107-404"><a href="#cb107-404" aria-hidden="true" tabindex="-1"></a><span class="co">//       double x_value = *((double*) x);</span></span>
<span id="cb107-405"><a href="#cb107-405" aria-hidden="true" tabindex="-1"></a><span class="co">//       double data_value = *((double*) data);</span></span>
<span id="cb107-406"><a href="#cb107-406" aria-hidden="true" tabindex="-1"></a><span class="co">//       return x_value &lt;= data_value;</span></span>
<span id="cb107-407"><a href="#cb107-407" aria-hidden="true" tabindex="-1"></a><span class="co">//     }</span></span>
<span id="cb107-408"><a href="#cb107-408" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-409"><a href="#cb107-409" aria-hidden="true" tabindex="-1"></a><span class="co">// Where the "data" argument will be passed through as the number to</span></span>
<span id="cb107-410"><a href="#cb107-410" aria-hidden="true" tabindex="-1"></a><span class="co">// search for.</span></span>
<span id="cb107-411"><a href="#cb107-411" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-412"><a href="#cb107-412" aria-hidden="true" tabindex="-1"></a><span class="co">// These functions return NULL if no entry is found, otherwise they</span></span>
<span id="cb107-413"><a href="#cb107-413" aria-hidden="true" tabindex="-1"></a><span class="co">// return the pointer to the largest entry in the buffer that the</span></span>
<span id="cb107-414"><a href="#cb107-414" aria-hidden="true" tabindex="-1"></a><span class="co">// predicate returns false.</span></span>
<span id="cb107-415"><a href="#cb107-415" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-416"><a href="#cb107-416" aria-hidden="true" tabindex="-1"></a><span class="co">// The _linear search does a naive linear search from the tail of the</span></span>
<span id="cb107-417"><a href="#cb107-417" aria-hidden="true" tabindex="-1"></a><span class="co">// buffer (i.e., the last entry that was added) towards the beginning.</span></span>
<span id="cb107-418"><a href="#cb107-418" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-419"><a href="#cb107-419" aria-hidden="true" tabindex="-1"></a><span class="co">// The _bisect search tries to be more clever and does a bisect</span></span>
<span id="cb107-420"><a href="#cb107-420" aria-hidden="true" tabindex="-1"></a><span class="co">// search.  It requires an initial guess "i" to the location of the</span></span>
<span id="cb107-421"><a href="#cb107-421" aria-hidden="true" tabindex="-1"></a><span class="co">// data.  You can provide '0' as 'i' to start at the tail.</span></span>
<span id="cb107-422"><a href="#cb107-422" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb107-423"><a href="#cb107-423" aria-hidden="true" tabindex="-1"></a><span class="co">// The "data" argument to both functions will be passed through to the</span></span>
<span id="cb107-424"><a href="#cb107-424" aria-hidden="true" tabindex="-1"></a><span class="co">// predicate function.</span></span>
<span id="cb107-425"><a href="#cb107-425" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">bool</span> ring_predicate<span class="op">(</span><span class="dt">const</span> <span class="dt">void</span> <span class="op">*</span>x<span class="op">,</span> <span class="dt">void</span> <span class="op">*</span>data<span class="op">);</span></span>
<span id="cb107-426"><a href="#cb107-426" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">void</span> <span class="op">*</span> ring_buffer_search_linear<span class="op">(</span><span class="dt">const</span> ring_buffer <span class="op">*</span>buffer<span class="op">,</span></span>
<span id="cb107-427"><a href="#cb107-427" aria-hidden="true" tabindex="-1"></a>                                       ring_predicate pred<span class="op">,</span> <span class="dt">void</span> <span class="op">*</span>data<span class="op">);</span></span>
<span id="cb107-428"><a href="#cb107-428" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">void</span> <span class="op">*</span> ring_buffer_search_bisect<span class="op">(</span><span class="dt">const</span> ring_buffer <span class="op">*</span>buffer<span class="op">,</span> <span class="dt">size_t</span> i<span class="op">,</span></span>
<span id="cb107-429"><a href="#cb107-429" aria-hidden="true" tabindex="-1"></a>                                       ring_predicate pred<span class="op">,</span> <span class="dt">void</span> <span class="op">*</span>data<span class="op">);</span></span>
<span id="cb107-430"><a href="#cb107-430" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-431"><a href="#cb107-431" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef __cplusplus</span></span>
<span id="cb107-432"><a href="#cb107-432" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb107-433"><a href="#cb107-433" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb107-434"><a href="#cb107-434" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<p>For a complete real-world example of use, see <a href="https://github.com/mrc-ide/dde" class="external-link">dde</a>, which uses a ring buffer
to hold the history of a set of differential equations, and uses that to
implement delay equations. Here, the ring buffer means that the memory
requirements don’t grow with the length of running the simulation (as it
only cares about fairly recent history, the natural overflow from the
ring buffer is well suited). The memory is only allocated at the
beginning of the simulation so there is no additional memory
allocations. And because <code>ring</code> returns (const) pointers to
the appropriate place in memory there is little copying.</p>
<p>A simple application that implements the same mean-reverting
simulation from above:</p>
<div class="sourceCode" id="cb108"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;ring/ring.h&gt;</span></span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;R.h&gt;</span></span>
<span id="cb108-4"><a href="#cb108-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;Rinternals.h&gt;</span></span>
<span id="cb108-5"><a href="#cb108-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-6"><a href="#cb108-6" aria-hidden="true" tabindex="-1"></a><span class="co">// Definition used below (can't be called step() because that may</span></span>
<span id="cb108-7"><a href="#cb108-7" aria-hidden="true" tabindex="-1"></a><span class="co">// conflict with regexp.h on some platforms).</span></span>
<span id="cb108-8"><a href="#cb108-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> step_x<span class="op">(</span>ring_buffer <span class="op">*</span>r<span class="op">,</span> <span class="dt">int</span> x<span class="op">);</span></span>
<span id="cb108-9"><a href="#cb108-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-10"><a href="#cb108-10" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> example<span class="op">(</span><span class="dt">size_t</span> nstep<span class="op">,</span> <span class="dt">double</span> <span class="op">*</span>ret<span class="op">)</span> <span class="op">{</span></span>
<span id="cb108-11"><a href="#cb108-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Construct a ring buffer of (max) size 5, each element of which is</span></span>
<span id="cb108-12"><a href="#cb108-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">// big enough to contain an integer (probably 4 bytes).</span></span>
<span id="cb108-13"><a href="#cb108-13" aria-hidden="true" tabindex="-1"></a>  ring_buffer <span class="op">*</span>r <span class="op">=</span> ring_buffer_create<span class="op">(</span><span class="dv">5</span><span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">),</span> OVERFLOW_OVERWRITE<span class="op">);</span></span>
<span id="cb108-14"><a href="#cb108-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-15"><a href="#cb108-15" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Starting point of the simulation, as in the R version:</span></span>
<span id="cb108-16"><a href="#cb108-16" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> x <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb108-17"><a href="#cb108-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-18"><a href="#cb108-18" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Push the initial state into the ring buffer:</span></span>
<span id="cb108-19"><a href="#cb108-19" aria-hidden="true" tabindex="-1"></a>  ring_buffer_push<span class="op">(</span>r<span class="op">,</span> <span class="op">&amp;</span>x<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb108-20"><a href="#cb108-20" aria-hidden="true" tabindex="-1"></a>  ret<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> x<span class="op">;</span></span>
<span id="cb108-21"><a href="#cb108-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-22"><a href="#cb108-22" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> nstep<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb108-23"><a href="#cb108-23" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> step_x<span class="op">(</span>r<span class="op">,</span> x<span class="op">);</span></span>
<span id="cb108-24"><a href="#cb108-24" aria-hidden="true" tabindex="-1"></a>    ring_buffer_push<span class="op">(</span>r<span class="op">,</span> <span class="op">&amp;</span>x<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb108-25"><a href="#cb108-25" aria-hidden="true" tabindex="-1"></a>    ret<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> x<span class="op">;</span></span>
<span id="cb108-26"><a href="#cb108-26" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb108-27"><a href="#cb108-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-28"><a href="#cb108-28" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Cleanup:</span></span>
<span id="cb108-29"><a href="#cb108-29" aria-hidden="true" tabindex="-1"></a>  ring_buffer_destroy<span class="op">(</span>r<span class="op">);</span></span>
<span id="cb108-30"><a href="#cb108-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb108-31"><a href="#cb108-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-32"><a href="#cb108-32" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> step_x<span class="op">(</span>ring_buffer <span class="op">*</span>r<span class="op">,</span> <span class="dt">int</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb108-33"><a href="#cb108-33" aria-hidden="true" tabindex="-1"></a>  <span class="dt">size_t</span> n <span class="op">=</span> ring_buffer_used<span class="op">(</span>r<span class="op">,</span> false<span class="op">);</span></span>
<span id="cb108-34"><a href="#cb108-34" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> p<span class="op">;</span></span>
<span id="cb108-35"><a href="#cb108-35" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;</span> <span class="dv">2</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb108-36"><a href="#cb108-36" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> <span class="fl">0.5</span><span class="op">;</span></span>
<span id="cb108-37"><a href="#cb108-37" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb108-38"><a href="#cb108-38" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Oldest non-overflowed element is in the tail.  Note that the</span></span>
<span id="cb108-39"><a href="#cb108-39" aria-hidden="true" tabindex="-1"></a>    <span class="co">// return value (which is void*) must be first cast to (int*) then</span></span>
<span id="cb108-40"><a href="#cb108-40" aria-hidden="true" tabindex="-1"></a>    <span class="co">// dereferenced.</span></span>
<span id="cb108-41"><a href="#cb108-41" aria-hidden="true" tabindex="-1"></a>    <span class="co">///</span></span>
<span id="cb108-42"><a href="#cb108-42" aria-hidden="true" tabindex="-1"></a>    <span class="co">// </span><span class="al">NOTE</span><span class="co">: In general, check that the return value here is not NULL</span></span>
<span id="cb108-43"><a href="#cb108-43" aria-hidden="true" tabindex="-1"></a>    <span class="co">// (indicating an underflow); here we're OK because we checked the</span></span>
<span id="cb108-44"><a href="#cb108-44" aria-hidden="true" tabindex="-1"></a>    <span class="co">// number of used elements at the beginning.</span></span>
<span id="cb108-45"><a href="#cb108-45" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x0 <span class="op">=</span> <span class="op">*(</span><span class="dt">int</span><span class="op">*)</span>ring_buffer_tail<span class="op">(</span>r<span class="op">);</span></span>
<span id="cb108-46"><a href="#cb108-46" aria-hidden="true" tabindex="-1"></a>    <span class="dt">size_t</span> increases <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb108-47"><a href="#cb108-47" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb108-48"><a href="#cb108-48" aria-hidden="true" tabindex="-1"></a>      <span class="co">// Moving through the more recently added elements:</span></span>
<span id="cb108-49"><a href="#cb108-49" aria-hidden="true" tabindex="-1"></a>      <span class="dt">int</span> x1 <span class="op">=</span> <span class="op">*(</span><span class="dt">int</span><span class="op">*)</span>ring_buffer_tail_offset<span class="op">(</span>r<span class="op">,</span> i<span class="op">);</span></span>
<span id="cb108-50"><a href="#cb108-50" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(</span>x1 <span class="op">&gt;</span> x0<span class="op">)</span> <span class="op">{</span></span>
<span id="cb108-51"><a href="#cb108-51" aria-hidden="true" tabindex="-1"></a>        increases<span class="op">++;</span></span>
<span id="cb108-52"><a href="#cb108-52" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb108-53"><a href="#cb108-53" aria-hidden="true" tabindex="-1"></a>      x0 <span class="op">=</span> x1<span class="op">;</span></span>
<span id="cb108-54"><a href="#cb108-54" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb108-55"><a href="#cb108-55" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> <span class="op">((</span><span class="dt">double</span><span class="op">)</span>increases<span class="op">)</span> <span class="op">/</span> <span class="op">(</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb108-56"><a href="#cb108-56" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb108-57"><a href="#cb108-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-58"><a href="#cb108-58" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>unif_rand<span class="op">()</span> <span class="op">&lt;</span> p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb108-59"><a href="#cb108-59" aria-hidden="true" tabindex="-1"></a>    <span class="op">--</span>x<span class="op">;</span></span>
<span id="cb108-60"><a href="#cb108-60" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb108-61"><a href="#cb108-61" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span>x<span class="op">;</span></span>
<span id="cb108-62"><a href="#cb108-62" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb108-63"><a href="#cb108-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-64"><a href="#cb108-64" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> x<span class="op">;</span></span>
<span id="cb108-65"><a href="#cb108-65" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb108-66"><a href="#cb108-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-67"><a href="#cb108-67" aria-hidden="true" tabindex="-1"></a><span class="co">// This function collects all the R API bits that deal with</span></span>
<span id="cb108-68"><a href="#cb108-68" aria-hidden="true" tabindex="-1"></a><span class="co">// communication between C and R.  "Writing R extensions" is the</span></span>
<span id="cb108-69"><a href="#cb108-69" aria-hidden="true" tabindex="-1"></a><span class="co">// canonical documentation source.</span></span>
<span id="cb108-70"><a href="#cb108-70" aria-hidden="true" tabindex="-1"></a>SEXP r_example<span class="op">(</span>SEXP r_nstep<span class="op">)</span> <span class="op">{</span></span>
<span id="cb108-71"><a href="#cb108-71" aria-hidden="true" tabindex="-1"></a>  <span class="dt">size_t</span> nstep <span class="op">=</span> <span class="op">(</span><span class="dt">size_t</span><span class="op">)</span> INTEGER<span class="op">(</span>r_nstep<span class="op">)[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb108-72"><a href="#cb108-72" aria-hidden="true" tabindex="-1"></a>  SEXP ret <span class="op">=</span> PROTECT<span class="op">(</span>allocVector<span class="op">(</span>REALSXP<span class="op">,</span> nstep<span class="op">));</span></span>
<span id="cb108-73"><a href="#cb108-73" aria-hidden="true" tabindex="-1"></a>  GetRNGstate<span class="op">();</span> <span class="co">// because we'll work with random numbers</span></span>
<span id="cb108-74"><a href="#cb108-74" aria-hidden="true" tabindex="-1"></a>  example<span class="op">(</span>nstep<span class="op">,</span> REAL<span class="op">(</span>ret<span class="op">));</span></span>
<span id="cb108-75"><a href="#cb108-75" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Cleanup:</span></span>
<span id="cb108-76"><a href="#cb108-76" aria-hidden="true" tabindex="-1"></a>  PutRNGstate<span class="op">();</span></span>
<span id="cb108-77"><a href="#cb108-77" aria-hidden="true" tabindex="-1"></a>  UNPROTECT<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb108-78"><a href="#cb108-78" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ret<span class="op">;</span></span>
<span id="cb108-79"><a href="#cb108-79" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb108-80"><a href="#cb108-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-81"><a href="#cb108-81" aria-hidden="true" tabindex="-1"></a><span class="co">// This can be included in a different file, or, for a single file</span></span>
<span id="cb108-82"><a href="#cb108-82" aria-hidden="true" tabindex="-1"></a><span class="co">// project like this one, include here.</span></span>
<span id="cb108-83"><a href="#cb108-83" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;ring/ring.c&gt;</span></span></code></pre></div>
<div class="section level3">
<h3 id="a-nontrivial-example">A nontrivial example<a class="anchor" aria-label="anchor" href="#a-nontrivial-example"></a>
</h3>
<p>In the <a href="https://github.com/mrc-ide/dde" class="external-link"><code>dde</code></a>
package (not yet on CRAN), I use ring buffers to solve delay
differential equations (DDEs). To solve these, we need to know the state
of the system at a series of points in the past. So at every time step
we push the state of the system onto a ring buffer. Then, as the solver
moves forward in time we can get the system at some previous point in
time by looking back through the ring buffer until the time in question
is found.</p>
<p>In this application a ring buffer is the ideal data structure because
we often want to solve equations where the time we look back is a small
fraction of the total time. Without a ring buffer we’d either have to
store the <em>entire</em> history (with a large memory cost, most of
which is not needed) or periodically copy the history around.</p>
<p>To use <code>ring</code> within the <code>dde</code> package:</p>
<ul>
<li><p>In the <code>DESCRIPTION</code> we <a href="https://github.com/mrc-ide/dde/blob/7ebaefd/DESCRIPTION#L14" class="external-link">declare
a link to <code>ring</code></a> using the <code>LinkingTo:</code>
field.</p></li>
<li><p>In the <code>src</code> directory, <a href="https://github.com/mrc-ide/dde/blob/7ebaefd/src/ring.c" class="external-link">the
contents of <code>&lt;ring/ring.c&gt;</code> are included</a>; this is
possible because of the <code>LinkingTo</code> field. This file now
includes all the actual ring buffer implementation.</p></li>
<li><p>In <a href="https://github.com/mrc-ide/dde/blob/7ebaefd/src/dopri.h#L8" class="external-link">src/dopri.h</a>
we include <code>&lt;ring/ring.h&gt;</code> which allows the ring buffer
code to be used in any file that includes <code>dopri.h</code>. There is
a <a href="https://github.com/mrc-ide/dde/blob/7ebaefd/src/dopri.h#L77-L111" class="external-link">data
structure in this header</a> that includes within itself a ring buffer
to hold the history.</p></li>
<li>
<p>In <a href="https://github.com/mrc-ide/dde/blob/7ebaefd/src/dopri.c" class="external-link">src/dopri.c</a>
the ring buffer code is actually used:</p>
<ul>
<li><a href="https://github.com/mrc-ide/dde/blob/7ebaefd/src/dopri.c#L48-L50" class="external-link">initialisation</a></li>
<li><a href="https://github.com/mrc-ide/dde/blob/7ebaefd/src/dopri.c#L694-L719" class="external-link">a
time is found within the ring buffer</a></li>
<li><a href="https://github.com/mrc-ide/dde/blob/7ebaefd/src/dopri.c#L417" class="external-link">the
ring buffer is advanced</a></li>
<li><a href="https://github.com/mrc-ide/dde/blob/7ebaefd/src/dopri.c#L220" class="external-link">the
data is freed</a></li>
</ul>
</li>
<li><p>In <a href="https://github.com/mrc-ide/dde/blob/7ebaefd/src/dopri_5.c#L109-L119" class="external-link">src/dopri_5.c</a>
new data is written to the head of the ring buffer, being the state of
the system at the end of the step. The history head is treated as a big
block of contiguous doubles.</p></li>
</ul>
<p>Used this way, the programmer can focus on simply writing to the
application and do as little work on bookkeeping as possible.</p>
</div>
</div>
<div class="section level2">
<h2 id="the-c-api-1">The C++ API<a class="anchor" aria-label="anchor" href="#the-c-api-1"></a>
</h2>
<p>If you’re using C++ you may find the <a href="https://www.boost.org/doc/libs/1_61_0/doc/html/circular_buffer.html" class="external-link">Boost
circular buffer</a> is likely to be far better; you can use this by
<code>LinkingTo:</code> the <code>BH</code> package and using
<code>#include &lt;boost/circular_buffer.hpp&gt;</code> in your
code.</p>
<p>Alternatively, the <code>ring</code> C code can be directly used in
C++ as above. Or, there is a class-based approach available:</p>
<ul>
<li><p>In your <code>src/</code> directory, add a file
<code>ring.cpp</code> containing just the line
<code>#include &lt;ring/ring.cpp&gt;</code></p></li>
<li><p>Anywhere in your code you want to use the ring buffer, include
the line <code>#include &lt;dde/dde.hpp&gt;</code> to include the class
definition:</p></li>
</ul>
<div class="sourceCode" id="cb109"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifndef _RING_HPP_</span></span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define _RING_HPP_</span></span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-4"><a href="#cb109-4" aria-hidden="true" tabindex="-1"></a><span class="co">// </span><span class="al">NOTE</span><span class="co">: the C++ version always uses non-R memory allocation functions</span></span>
<span id="cb109-5"><a href="#cb109-5" aria-hidden="true" tabindex="-1"></a><span class="co">// because otherwise the R error can jump over destructors causing</span></span>
<span id="cb109-6"><a href="#cb109-6" aria-hidden="true" tabindex="-1"></a><span class="co">// memory leaks or worse.  Errors will be thrown with "throw", which</span></span>
<span id="cb109-7"><a href="#cb109-7" aria-hidden="true" tabindex="-1"></a><span class="co">// Rcpp will catch if you use that.</span></span>
<span id="cb109-8"><a href="#cb109-8" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb109-9"><a href="#cb109-9" aria-hidden="true" tabindex="-1"></a><span class="co">// However, note that if using overflow_action of anything other than</span></span>
<span id="cb109-10"><a href="#cb109-10" aria-hidden="true" tabindex="-1"></a><span class="co">// OVERFLOW_OVERWRITE is possibly unsafe; OVERFLOW_GROW is fine so</span></span>
<span id="cb109-11"><a href="#cb109-11" aria-hidden="true" tabindex="-1"></a><span class="co">// long as you never run out of memory, and OVERFLOW_ERROR is probably</span></span>
<span id="cb109-12"><a href="#cb109-12" aria-hidden="true" tabindex="-1"></a><span class="co">// never safe.</span></span>
<span id="cb109-13"><a href="#cb109-13" aria-hidden="true" tabindex="-1"></a><span class="pp">#define RING_USE_STDLIB_ALLOC </span><span class="dv">1</span></span>
<span id="cb109-14"><a href="#cb109-14" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;ring/ring.h&gt;</span></span>
<span id="cb109-15"><a href="#cb109-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-16"><a href="#cb109-16" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> RingBuffer <span class="op">{</span></span>
<span id="cb109-17"><a href="#cb109-17" aria-hidden="true" tabindex="-1"></a>  ring_buffer <span class="op">*</span> buffer<span class="op">;</span></span>
<span id="cb109-18"><a href="#cb109-18" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb109-19"><a href="#cb109-19" aria-hidden="true" tabindex="-1"></a>  RingBuffer<span class="op">(</span><span class="dt">size_t</span> size<span class="op">,</span> <span class="dt">size_t</span> stride<span class="op">,</span> overflow_action on_overflow<span class="op">);</span></span>
<span id="cb109-20"><a href="#cb109-20" aria-hidden="true" tabindex="-1"></a>  <span class="op">~</span>RingBuffer<span class="op">();</span></span>
<span id="cb109-21"><a href="#cb109-21" aria-hidden="true" tabindex="-1"></a>  RingBuffer<span class="op">(</span><span class="at">const</span> RingBuffer<span class="op">&amp;</span> other<span class="op">);</span></span>
<span id="cb109-22"><a href="#cb109-22" aria-hidden="true" tabindex="-1"></a>  RingBuffer<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">=(</span>RingBuffer other<span class="op">);</span></span>
<span id="cb109-23"><a href="#cb109-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-24"><a href="#cb109-24" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> grow<span class="op">(</span><span class="dt">size_t</span> n<span class="op">,</span> <span class="dt">bool</span> exact<span class="op">);</span></span>
<span id="cb109-25"><a href="#cb109-25" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> reset<span class="op">(</span><span class="dt">bool</span> clear<span class="op">);</span></span>
<span id="cb109-26"><a href="#cb109-26" aria-hidden="true" tabindex="-1"></a>  <span class="dt">size_t</span> size<span class="op">(</span><span class="dt">bool</span> bytes<span class="op">)</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb109-27"><a href="#cb109-27" aria-hidden="true" tabindex="-1"></a>  <span class="dt">size_t</span> free<span class="op">(</span><span class="dt">bool</span> bytes<span class="op">)</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb109-28"><a href="#cb109-28" aria-hidden="true" tabindex="-1"></a>  <span class="dt">size_t</span> used<span class="op">(</span><span class="dt">bool</span> bytes<span class="op">)</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb109-29"><a href="#cb109-29" aria-hidden="true" tabindex="-1"></a>  <span class="dt">size_t</span> bytes_data<span class="op">()</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb109-30"><a href="#cb109-30" aria-hidden="true" tabindex="-1"></a>  <span class="dt">bool</span> is_full<span class="op">()</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb109-31"><a href="#cb109-31" aria-hidden="true" tabindex="-1"></a>  <span class="dt">bool</span> is_empty<span class="op">()</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb109-32"><a href="#cb109-32" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">void</span> <span class="op">*</span> data<span class="op">()</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb109-33"><a href="#cb109-33" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">void</span> <span class="op">*</span> head<span class="op">()</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb109-34"><a href="#cb109-34" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">void</span> <span class="op">*</span> tail<span class="op">()</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb109-35"><a href="#cb109-35" aria-hidden="true" tabindex="-1"></a>  <span class="dt">size_t</span> head_pos<span class="op">(</span><span class="dt">bool</span> bytes<span class="op">)</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb109-36"><a href="#cb109-36" aria-hidden="true" tabindex="-1"></a>  <span class="dt">size_t</span> tail_pos<span class="op">(</span><span class="dt">bool</span> bytes<span class="op">)</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb109-37"><a href="#cb109-37" aria-hidden="true" tabindex="-1"></a>  <span class="dt">size_t</span> set<span class="op">(</span><span class="dt">data_t</span> c<span class="op">,</span> <span class="dt">size_t</span> len<span class="op">);</span></span>
<span id="cb109-38"><a href="#cb109-38" aria-hidden="true" tabindex="-1"></a>  <span class="dt">size_t</span> set_stride<span class="op">(</span><span class="at">const</span> <span class="dt">void</span> <span class="op">*</span>x<span class="op">,</span> <span class="dt">size_t</span> len<span class="op">);</span></span>
<span id="cb109-39"><a href="#cb109-39" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">void</span> <span class="op">*</span> push<span class="op">(</span><span class="at">const</span> <span class="dt">void</span> <span class="op">*</span>src<span class="op">,</span> <span class="dt">size_t</span> n<span class="op">);</span></span>
<span id="cb109-40"><a href="#cb109-40" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">void</span> <span class="op">*</span> take<span class="op">(</span><span class="dt">void</span> <span class="op">*</span>dest<span class="op">,</span> <span class="dt">size_t</span> n<span class="op">);</span></span>
<span id="cb109-41"><a href="#cb109-41" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">void</span> <span class="op">*</span> read<span class="op">(</span><span class="dt">void</span> <span class="op">*</span>dest<span class="op">,</span> <span class="dt">size_t</span> n<span class="op">)</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb109-42"><a href="#cb109-42" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">void</span> <span class="op">*</span> copy<span class="op">(</span>RingBuffer<span class="op">&amp;</span> dest<span class="op">,</span> <span class="dt">size_t</span> n<span class="op">);</span></span>
<span id="cb109-43"><a href="#cb109-43" aria-hidden="true" tabindex="-1"></a>  <span class="dt">bool</span> mirror<span class="op">(</span>RingBuffer<span class="op">&amp;</span> dest<span class="op">)</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb109-44"><a href="#cb109-44" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">void</span> <span class="op">*</span> tail_offset<span class="op">(</span><span class="dt">size_t</span> offset<span class="op">)</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb109-45"><a href="#cb109-45" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">void</span> <span class="op">*</span> head_offset<span class="op">(</span><span class="dt">size_t</span> offset<span class="op">)</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb109-46"><a href="#cb109-46" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb109-47"><a href="#cb109-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-48"><a href="#cb109-48" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p></p>
<p>Developed by Rich FitzJohn.</p>
</div>

<div class="pkgdown">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

      </footer>
</div>

  


  

  </body>
</html>
