[{"path":"https://mrc-ide.github.io/ring/CONDUCT.html","id":null,"dir":"","previous_headings":"","what":"Contributor Code of Conduct","title":"Contributor Code of Conduct","text":"contributors maintainers project, pledge respect people contribute reporting issues, posting feature requests, updating documentation, submitting pull requests patches, activities. committed making participation project harassment-free experience everyone, regardless level experience, gender, gender identity expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion. Examples unacceptable behavior participants include use sexual language imagery, derogatory comments personal attacks, trolling, public private harassment, insults, unprofessional conduct. Project maintainers right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct. Project maintainers follow Code Conduct may removed project team. Instances abusive, harassing, otherwise unacceptable behavior may reported opening issue contacting one project maintainers. Code Conduct adapted Contributor Covenant (http:contributor-covenant.org), version 1.0.0, available http://contributor-covenant.org/version/1/0/0/","code":""},{"path":"https://mrc-ide.github.io/ring/articles/ring.html","id":"the-environment-buffer-ring_buffer_env","dir":"Articles","previous_headings":"","what":"The environment buffer ring_buffer_env","title":"ring","text":"simplest buffer understand don’t deal raw vectors. create buffer can hold 100 elements, use ring_buffer_env function: R6 class, several methods: Operations class happen running methods using $. size buffer: …number elements free used: …whether buffer empty full: start using buffer need put data . two main functions adding data: buf$set(data, n) sets n elements value data buf$push(data, iterate) pushes data buffer, iterate argument indicating iterate data treat single element set first 5 elements “”, “b”, …, “e”, use: buffer longer empty …5 elements: …room 95 : read content buffer without modifying , use read(n) n number elements read. always returns list length n: try read far, buffer underflow get error: just want first element, use tail() tail returns first element (buffer naturally operates first--first-queue). can also read recently added element head() can offset integer number steps. moving one position buffer tail gets second element added: moving three elements buffer head (recently added element) gets bit data operations nondestructive – leave buffer unchanged. consume elements, use take(n) operates way read also moves buffer tail; consumes elements leaving space . Now consumed element tail moved along, tail contains “b” “” removed buffer: reset buffer, use reset(). empties buffer data: ring buffer fixed size typical use, can grow explicitly. add additional space, use grow method:","code":"buf <- ring::ring_buffer_env(100) buf ## <Ring Buffer (ring_buffer_env)> ##   Public: ##     copy: function (dest, n) ##     duplicate: function () ##     free: function () ##     grow: function (n) ##     head: function () ##     head_advance: function () ##     head_data: function () ##     head_offset: function (n) ##     head_pos: function () ##     head_set: function (data) ##     is_empty: function () ##     is_full: function () ##     mirror: function (dest) ##     push: function (data, iterate = TRUE) ##     read: function (n) ##     read_head: function (n) ##     reset: function (clear = FALSE) ##     set: function (data, n) ##     size: function () ##     tail: function () ##     tail_offset: function (n) ##     tail_pos: function () ##     take: function (n) ##     take_head: function (n) ##     used: function () buf$size() ## [1] 100 buf$free() ## [1] 100 buf$used() ## [1] 0 buf$is_empty() ## [1] TRUE buf$is_full() ## [1] FALSE buf$push(letters[1:5]) buf$is_empty() ## [1] FALSE buf$used() ## [1] 5 buf$free() ## [1] 95 buf$read(1) ## [[1]] ## [1] \"a\" buf$read(2) ## [[1]] ## [1] \"a\" ##  ## [[2]] ## [1] \"b\" buf$read(20) ## Error: Buffer underflow (requested 20 elements but 5 available) buf$tail() ## [1] \"a\" buf$head() ## [1] \"e\" buf$tail_offset(1) ## [1] \"b\" buf$head_offset(3) ## [1] \"b\" buf$free() ## [1] 95 buf$take(1) ## [[1]] ## [1] \"a\" buf$free() ## [1] 96 buf$tail() ## [1] \"b\" buf$reset() buf$used() ## [1] 0 buf$is_empty() ## [1] TRUE buf$size() ## [1] 100 buf$grow(20) buf$size() ## [1] 120"},{"path":"https://mrc-ide.github.io/ring/articles/ring.html","id":"application-simulation-with-recent-history","dir":"Articles","previous_headings":"The environment buffer ring_buffer_env","what":"Application: simulation with recent history","title":"ring","text":"whole point ring buffer though can push things onto pull recent , even number things pushed overall larger buffer size. imagine simulation need keep track last 5 steps. simulation random walk. whole history: last 5 steps: rewrite simulation random walk tends last steps increases tends last steps decreases: Now simulation strong mean reverting tendency:  buffer always holds last 5 (fewer) elements book-keeping involved working last elements simplified. Ignoring fact hold entire history fixed size vector h, last elements need retained may useful simulation generates lot data. downside implementation buf$read() returns list must turned vector unlist, even though know case simulation always produce integer vector. ring buffers described can help problem.","code":"step <- function(x) {   if (runif(1) < 0.5) x - 1L else x + 1L }  x <- 0L buf <- ring::ring_buffer_env(5) h <- integer(20) buf$push(x) h[1L] <- x  set.seed(1) for (i in seq_len(length(h) - 1L)) {   x <- step(x)   buf$push(x)   h[i + 1L] <- x } h ##  [1]  0 -1 -2 -1  0 -1  0  1  2  3  2  1  0  1  0  1  0  1  2  1 unlist(buf$read(5)) ## [1] 1 0 1 2 1 step <- function(x) {   if (length(x) > 1) {     p <- mean(diff(x)) / 2 + 0.5   } else {     p <- 0.5   }   if (runif(1) < p) x[length(x)] - 1L else x[length(x)] + 1L }  x <- 0L buf <- ring::ring_buffer_env(5) h <- integer(100) buf$push(x) h[1L] <- x  set.seed(1) for (i in seq_len(length(h) - 1L)) {   x <- step(unlist(buf$read(buf$used())))   buf$push(x)   h[i + 1L] <- x } par(mar = c(4, 4, .5, .5)) plot(h, type = \"l\", xlab = \"step\", ylab = \"y\", las = 1)"},{"path":"https://mrc-ide.github.io/ring/articles/ring.html","id":"the-bytes-buffer-ring_buffer_bytes","dir":"Articles","previous_headings":"","what":"The bytes buffer ring_buffer_bytes","title":"ring","text":"classical implementation ring buffer, implementation broadly based one , @dhess. operates basically way ring_buffer_env, presents similar interface R, key differences: contents buffer raw bytes (using R’s raw vectors). bit fiddly work can powerful. iterate distinction push disappears ambiguity R objects construct buffer 1000 bytes: methods apply directly: Generate byte sequence: …push buffer: …read buffer …destructively take oldest elements","code":"buf <- ring::ring_buffer_bytes(1000) buf$free() ## [1] 1000 buf$used() ## [1] 0 buf$is_full() ## [1] FALSE buf$is_empty() ## [1] TRUE bytes <- as.raw(0:255) buf$push(bytes) buf$read(10) ##  [1] 00 01 02 03 04 05 06 07 08 09 buf$used() ## [1] 256 buf$take(20) ##  [1] 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 buf$used() ## [1] 236"},{"path":"https://mrc-ide.github.io/ring/articles/ring.html","id":"striding","dir":"Articles","previous_headings":"The bytes buffer ring_buffer_bytes","what":"Striding","title":"ring","text":"Single bytes can hold values 0 255 (character equivalents, becomes 61 via charToRaw(\"\"). want hold full integer, (usually) takes 4 bytes, double (usually) takes 8. allow , bytes buffer can “strided”; indicates number consecutive bytes together make one logical entry. buffer contains size . create buffer 100 entries, 8 bytes : element pushed onto buffer must correct size. push byte sequence 1..8 onto buffer: pushed less error: Reading happens logical units, bytes: can get number elements used: number bytes","code":"buf <- ring::ring_buffer_bytes(100, 8) buf$push(as.raw(1:8)) buf$push(as.raw(1:4)) ## Error in buf$push(as.raw(1:4)): Incorrect size data; expected multiple of 8 bytes buf$read(1) ## [1] 01 02 03 04 05 06 07 08 buf$used() ## [1] 1 buf$used(bytes = TRUE) ## [1] 8"},{"path":"https://mrc-ide.github.io/ring/articles/ring.html","id":"the-typed-bytes-buffer-ring_buffer_bytes_typed","dir":"Articles","previous_headings":"The bytes buffer ring_buffer_bytes","what":"The typed bytes buffer ring_buffer_bytes_typed","title":"ring","text":"8 bytes double, possible make bytes buffer holds one () doubles per entry. ring_buffer_bytes_typed buffer , corner cases dealt . use, decide R interpretation entry , determine size per entry appropriate encoding decoding functions can ignore storing bytes. performance reasons use R’s serialisation simply copies data stored vectors. example, make buffer 10 elements, single real number (double), use: onto real numbers can pushed: retrieve data. Entries can contain one number; make buffer length 10, element vector 5 doubles: just implemented byte array, can just push bunch numbers straight buffer: elements buffer, can request . integer argument take indicates number groups 5 doubles like back: try take buffer error:","code":"buf <- ring::ring_buffer_bytes_typed(10, double(1)) buf$push(pi) buf$take(1) ## [1] 3.141593 buf <- ring::ring_buffer_bytes_typed(10, double(5)) buf$push(rnorm(5)) buf$read(1) ## [1]  0.26613736 -0.37670272  2.44136463 -0.79533912 -0.05487747 buf$push(rnorm(5 * 10)) buf$take(1) ## [1]  0.2501413  0.6182433 -0.1726235 -2.2239003 -1.2636144 buf$take(10) ## Error in super$take(n): Buffer underflow (requested 10 elements but 9 available)"},{"path":"https://mrc-ide.github.io/ring/articles/ring.html","id":"the-translating-bytes-buffer-ring_buffer_bytes_translate","dir":"Articles","previous_headings":"The bytes buffer ring_buffer_bytes","what":"The translating bytes buffer ring_buffer_bytes_translate","title":"ring","text":"ring_buffer_bytes_typed function implemented translating R objects bytes (storing $set(), $push(), etc). bytes back R objects (retrieving $read(), $take(), etc). ring_buffer_bytes_translate exposes interface. “typed” buffers allow storing strings can number bytes long (bytes buffers require fixed “stride” within buffer). can store fixed length strings. convert string byte sequence, use charToRaw (.raw(utf8ToInt(x)), multi-byte sequences might start difficult). inverse transformation rawToChar (intToUtf8(.integer(x))): function ring_buffer_bytes_translate takes functions 3rd fourth arguments. make buffer hold 100 strings, 8 bytes: can now store 8 character strings: length strings added: Probably useful storing just single characters make buffer text.","code":"(bytes <- charToRaw(\"hello world\")) ##  [1] 68 65 6c 6c 6f 20 77 6f 72 6c 64 rawToChar(bytes) ## [1] \"hello world\" b <- ring::ring_buffer_bytes_translate(100, 8, charToRaw, rawToChar) b$push(\"abcdefgh\") b$tail() ## [1] \"abcdefgh\" b$push(\"hello!\") ## Error in super$push(self$.to(data)): Incorrect size data; expected multiple of 8 bytes"},{"path":"https://mrc-ide.github.io/ring/articles/ring.html","id":"the-c-api","dir":"Articles","previous_headings":"","what":"The C API","title":"ring","text":"ring package can used R packages using LinkingTo mechanism. : DESCRIPTION, add line LinkingTo: ring (need include ring Depends Imports need package build). src/ directory, add file ring.c containing just line #include <ring/ring.c> (see note documentation ring_buffer_create ). Anywhere code want use ring buffer, include line #include <dde/dde.h> include prototypes use interface described . (sure best practice way standalone shared library compiled R CMD SHLIB though; probably best make package.) C API documented header file, fairly straightforward use (reference docs ; code underlying ring_buffer_bytes interface). complete real-world example use, see dde, uses ring buffer hold history set differential equations, uses implement delay equations. , ring buffer means memory requirements don’t grow length running simulation (cares fairly recent history, natural overflow ring buffer well suited). memory allocated beginning simulation additional memory allocations. ring returns (const) pointers appropriate place memory little copying. simple application implements mean-reverting simulation :","code":"#ifndef _RING_H_ #define _RING_H_ #include <stddef.h> #include <stdbool.h>  #ifndef RING_USE_STDLIB_ALLOC #ifndef USING_R #define USING_R #endif #endif  // Allow use from C++ #ifdef __cplusplus extern \"C\" { #endif  // What to do on overflow. // // The OVERFLOW_ERROR action (which calls R's error function) is only // available when using R, which is detected by the <R.h> header // included.  If you are using RING_USE_STDLIB_ALLOC (see below) but // want to use OVERFLOW_ERROR then you'll need to include <R.h> as // well, and be willing to deal with an R error and the longjmp that // it causes. typedef enum overflow_action {   OVERFLOW_OVERWRITE,   OVERFLOW_GROW #ifdef USING_R   , OVERFLOW_ERROR #endif } overflow_action;  // The underlying data structure.  None of the fields here should be // directly accessed in normal use; use the accessor functions // instead. // // The ring buffer is a FIFO (first-in-first-out) queue.  It is // implemented as a single block of memory (data) and a pair of // pointers: // //   head: the starting location where data should be written when //         copying data *into* the buffer. // //   tail: the starting location where data should be read when //         copying data *from* the buffer. // // The buffer has a concept of a stride; the number of bytes per // buffer entry.  This is fixed across the entire ring.  As such, some // functions that return size_t have a booleanargument \"bytes\" that // switches between measuring in bytes and measuring in logical // elements.  In the case where stride=1, these are identical. // // In general, the ring buffer is totally happy to overflow; if you // write too much into the ring buffer it will destructively erase // data (i.e., your tail will move).  The ring buffer will never // underflow, but functions may return `NULL` on underflow - read the // documentation below carefully. typedef unsigned char data_t; typedef struct ring_buffer {   size_t size;   size_t stride;   size_t bytes_data;   overflow_action on_overflow;    data_t *data;   data_t *head;   data_t *tail; } ring_buffer;  //// Creation, deletion, etc: ////  // Create a ring buffer.  After creating, be sure to free the memory // with `ring_buffer_destroy`. // //   size: (maximum) number of elements that the ring buffer may contain // //   stride: number of *bytes* per ring buffer element // // See the note above the struct for details on size/stride. // // If the buffer cannot be allocated (e.g., too big a buffer is // requested) then an R error will be thrown as this uses `Calloc`. // // This may not always be desirable (e.g., if using from within C++, // or in a project that does not actually use R).  To use plain C // stdlib calloc/free, in the ring.c use: // //     #define RING_USE_STDLIB_ALLOC 1 //     #include <ring/ring.c> // // which will not depend on *any* R code and use stdlib calloc/free // (except for the issue with USING_R/OVERFLOW_ERROR above).  With // RING_USE_STDLIB_ALLOC defined, if an allocation fails, then // ring_buffer_create (and ring_buffer_duplicate below) will return // NULL.  So if using this approach be sure to check the return value! // // The main wrinkle to using RING_USE_STDLIB_ALLOC 1 is that the // `overflow_action` `OVERFLOW_ERROR` will not work.  At present this // will fail to compile, but in future I may add an error handler. ring_buffer * ring_buffer_create(size_t size, size_t stride,                                  overflow_action on_overflow);  // Destroy a ring buffer.  Frees the memory // //   buffer: the ring buffer to copy; after calling this function all //           memory associated with the buffer is freed. void ring_buffer_destroy(ring_buffer *buffer);  // Duplicate (copy) a ring buffer.  Copies both the underlying data and // the position of the head and tail.  A new buffer will be allocated // and must be freed when finished with, using `ring_buffer_destroy` // //   buffer: a ring buffer to copy from; will not be modified ring_buffer * ring_buffer_duplicate(const ring_buffer *buffer);  // Increase the size of the ring buffer so that it can hold additional // elements.  This does not alter existing elements but increases the // capacity (similar to he `reserve` method in the C++ standard // library). // //   buffer: a ring buffer to increase the size of // //   n: the number of elements to increase the buffer by // //   exact: boolean, indicating if the buffer should be increased by //          exactly `n` elements (if true) or by at least `n` elements //          (if false).  If using the inexact method, the buffer is //          increased in size using geometric growth using the golden //          ratio. // // After using this function, all references to the head or tail are // broken and the memory may have been freed and the contents moved // elsewhere. // // If RING_USE_STDLIB_ALLOC is defined, and if an allocation fails, // then this may leave things in an undesirable state (this is // particularly a problem when using on_overflow = OVERFLOW_GROW). // Currently, if R is used an R error will be thrown (possibly not a // good idea if running under Rcpp) and if running as a standalone // application then the data will be set to NULL, probably causing a // crash pretty quickly (improvements welcome). void ring_buffer_grow(ring_buffer *buffer, size_t n, bool exact);  // Reset the state of the buffer.  This \"zeros\" the head and tail // pointer (and may or may not actually reset the data) so that the // buffer can be used as if fresh. // //   buffer: a ring buffer to reset // //   clear: boolean, indicating if memory should also be zeroed void ring_buffer_reset(ring_buffer *buffer, bool clear);  //// Basic querying: ////  // Return the maximum size of the ring buffer // //   buffer: the ring buffer to test (will not be modified) // //   bytes: indicates if size should be in bytes (if true) or elements //          (if false) size_t ring_buffer_size(const ring_buffer *buffer, bool bytes);  // Report the free and used space in the ring buffer // //   buffer: the ring buffer to test (will not be modified) // //   bytes: indicates if used/free space should be in bytes (if true) //          or elements (if false) size_t ring_buffer_free(const ring_buffer *buffer, bool bytes); size_t ring_buffer_used(const ring_buffer *buffer, bool bytes);  // Report the number of bytes of data that have been allocated.  Note // that this is likely `stride` more bytes than was requested as this // avoids a lot of awkward bookkeeping later, allowing the \"full\" // state to be distinguished from the \"empty\" state. size_t ring_buffer_bytes_data(const ring_buffer *buffer);  // Report if the ring buffer is full or empty bool ring_buffer_is_full(const ring_buffer *buffer); bool ring_buffer_is_empty(const ring_buffer *buffer);  //// Additional querying: ////  // Return the position of the head and tail pointers relative to the // data pointer (this is an offset, so 0 means the pointer is at the // start of the data array). // //   bytes: indicates if offset should be bytes (if true) or elements (if false) size_t ring_buffer_head_pos(const ring_buffer *buffer, bool bytes); size_t ring_buffer_tail_pos(const ring_buffer *buffer, bool bytes);  // Return pointers to the the data, head and tail members of the ring // buffer.  These are preferred over directly accessing the \"data\", // \"head\" and \"tail\" elements of the ring buffer structure itself // because with these the compiler will enforce read-only access for // you. // // WARNING: the head buffer is *not* the most recently added element, // but instead the bit of memory that will be written to next; it's // generally not terribly useful and a better way of getting the last // written element is to use: // //   ring_buffer_head_offset(buffer, 0); // // which will look after wrapping the ring buffer appropriately. const void * ring_buffer_data(const ring_buffer *buffer); const void * ring_buffer_head(const ring_buffer *buffer); const void * ring_buffer_tail(const ring_buffer *buffer);  //// Setting repeated values: ////  // Set all bytes of a length of the buffer to 'c'.  Here, 'len' is the // number of *entries*, so stride * len bytes will be set.  This will // mostly be uesful with c=0. // //   buffer: the ring buffer to set data into // //   c: value (0-255) to set all bytes to // //   n: number of elements to set // // This starts adding data at `head`.  If the buffer will overflow, at // most `bytes_data` bytes will be written (i.e., each element will be // written to once). // // Returns the number of bytes actually written to the buffer (so if // the buffer overflows this may be less than `len`). size_t ring_buffer_set(ring_buffer *buffer, data_t c, size_t n);  // Set a number of the elements of the buffer to a particular byte // pattern.  In contrast with `ring_buffer_set`, this does not set // individual bytes, but instead complete elements. // //    buffer: the ring buffer to set data into // //    x: pointer to a set of data to copy into the ring buffer.  This //            must be (at least) stride bytes long. // //    n: number of elements to set // // This starts adding data at `head`.  If the buffer will overflow, at // most `bytes_data` bytes will be written (i.e., each element will be // written to once). size_t ring_buffer_set_stride(ring_buffer *buffer, const void *x, size_t n);  //// Read and write ////  // Copy `n` entries, each of `stride` bytes from a contiguous memory // area src into the ring `buffer`. Returns the ring buffer's new head // pointer. // // It is possible to overflow the buffer with this function // //   buffer: the ring buffer to copy data into // //   src: the source memory to copy from (make sure this is big enough //           or you will get crashes and other terrible things). // //   n: the number of entries to copy from `src` into `buffer` (each //           of which is `stride` bytes long). const void * ring_buffer_push(ring_buffer *buffer, const void *src, size_t n);  // Destructively copy `n` entries (each of which is `stride` bytes) // from a ring buffer `buffer` into contiguous memory region `dest`. // This updates the `tail` pointers in the ring buffer and returns the // new tail pointer. // // The `n` entries will no longer be available in the ring buffer. // To do a nondestructive read, use `ring_buffer_read()`. // //   buffer: the ring buffer to copy data from // //   dest: the destination memory to copy into (make sure this is big enough //           or you will get crashes and other terrible things). // //   n: the number of entries to copy from `src` into `buffer` (each //           of which is `stride` bytes long). // // This function will not allow the ring buffer to underflow.  If // `n` is greater than the number of available entries, then // nothing is copied (and the ring buffer remains unmodified) and NULL // is returned. const void * ring_buffer_take(ring_buffer *buffer, void *dest, size_t n);  // Nondestructively read from a ring buffer.  This function is // essentially identical to `ring_buffer_take` but does not alter the // tail pointer. const void * ring_buffer_read(const ring_buffer *buffer, void *dest, size_t n);  // ring_buffer_take_head and ring_buffer_read_head are like // ring_buffer_take and ring_buffer_read (respectively) but operate on // the *head* of the ring (i.e., removing the most recently added // elements rather than the oldest elements). // // Neither will underflow, returning NULL if there are not enough // elements, and without copying anything. const void * ring_buffer_take_head(ring_buffer *buffer, void *dest, size_t n); const void * ring_buffer_read_head(const ring_buffer *buffer, void *dest,                                    size_t n);  // Copy `n` entries (each of `stride` bytes) from one ring buffer // `src` into another `dest`.  The copy starts at the tail of this // ring buffer, pushing onto the head of the destination buffer. // //   src: A ring buffer to copy data from  //   dest: A ring buffer to copy data into // //   n: the number of entries to copy (each of which is `stride` bytes) // // This is destructive to both buffers as pointers will be updated in // both. // // This function returns the new head pointer of the destination buffer. // // It is not possible to underflow `src`; if too few entries are // available, then nothing is copied, `src` and `dest` are not // modified, and the function returns NULL // // It is possible to overflow `dest` and the tail pointer will be // updated appropriately if so. // // Warning: the two buffers must have the same stride.  If the buffers // do not have the same stride, the function will return NULL (this // means if the function returns NULL it could either be an underflow // or an incompatible buffer). const void * ring_buffer_copy(ring_buffer *src, ring_buffer *dest, size_t n);  // Mirror the contents of ring buffer `src` into ring buffer `dest`. // This differs from `ring_buffer_copy` in that the `src` buffer is // not modified and that the *entire* state of the ring buffer is // duplicated. // // The function requires (and checks) that `src` and `dest` agree on // size and stride (and therefore total bytes).  It returns `true` if // the mirror was done, and `false` if the buffers are incompatible. // // This function will destroy all data in `dest`, but not allocate any // memory. // // Warning: the two buffers must have the same stride *and* the same // size.  If they do not, the function will return NULL (this means if // the function returns NULL it could either be an underflow or an // incompatible buffer). bool ring_buffer_mirror(const ring_buffer *src, ring_buffer *dest);  // Returns a pointer to the tail (reading end) of the buffer, offset // by `offset` entries.  When used as `ring_buffer_tail_offset(x, 0)` // this is equivalent to `ring_buffer_tail(x)` except that it will do // underflow checking. // //   buffer: the ring buffer to use // //   offset: the number of entries (each of which are `stride` bytes) //           to offset by // // It is not possible to underflow the buffer here; if `offset` is so // large that it would underflow, then NULL will be returned. const void * ring_buffer_tail_offset(const ring_buffer *buffer, size_t offset);  // As for `ring_buffer_tail_offset`, but offsetting the *head* // pointer.  This offsets in the opposite direction (moving from the // most recently added element towards the oldest element). const void * ring_buffer_head_offset(const ring_buffer *buffer, size_t offset);  //// For advanced use: ////  // Advance the ring buffer by one entry and return a pointer to the // memory *without writing anything to it*.  In this case, the calling // function is responsible for setting the memory to something // sensible.  This is currently used in the dde package where we want // to write directly to the head. // // This is (roughly) equivalent to: // //    ring_buffer_set(buffer, 0, 1); //    return buffer->head; // // but does not actually copy any data. // // Note that the pointer returned is *not* const; this is always used // in a case where the aim is to write to the head directly! void * ring_buffer_head_advance(ring_buffer *buffer);  //// Search: ////  // There are two functions for searching for data within a ring buffer // that consists of *sorted* entries.  This might be the case if // entries are added sequentially with (say) a timestamp. // // To locate an entry, a predicate function (pointer) must be // provided.  This must be a function taking two void pointers as // arguments; the first will be the pointer to an entry in the ring // buffer, the second will be any data that *you* provide (may be // NULL).  This function must return \"true\" if the value is *less // than* the target value (i.e. true if we should search *earlier* in // the buffer).  The \"x\" argument must be treated as read-only. // // For example, a predictate function that would find an entry where // the first 8 bytes of a ring buffer entry represent doubles could be // written as: // //     bool test_find_double(const void *x, void *data) { //       double x_value = *((double*) x); //       double data_value = *((double*) data); //       return x_value <= data_value; //     } // // Where the \"data\" argument will be passed through as the number to // search for. // // These functions return NULL if no entry is found, otherwise they // return the pointer to the largest entry in the buffer that the // predicate returns false. // // The _linear search does a naive linear search from the tail of the // buffer (i.e., the last entry that was added) towards the beginning. // // The _bisect search tries to be more clever and does a bisect // search.  It requires an initial guess \"i\" to the location of the // data.  You can provide '0' as 'i' to start at the tail. // // The \"data\" argument to both functions will be passed through to the // predicate function. typedef bool ring_predicate(const void *x, void *data); const void * ring_buffer_search_linear(const ring_buffer *buffer,                                        ring_predicate pred, void *data); const void * ring_buffer_search_bisect(const ring_buffer *buffer, size_t i,                                        ring_predicate pred, void *data);  #ifdef __cplusplus } #endif #endif #include <ring/ring.h>  #include <R.h> #include <Rinternals.h>  // Definition used below (can't be called step() because that may // conflict with regexp.h on some platforms). int step_x(ring_buffer *r, int x);  void example(size_t nstep, double *ret) {   // Construct a ring buffer of (max) size 5, each element of which is   // big enough to contain an integer (probably 4 bytes).   ring_buffer *r = ring_buffer_create(5, sizeof(int), OVERFLOW_OVERWRITE);    // Starting point of the simulation, as in the R version:   int x = 0;    // Push the initial state into the ring buffer:   ring_buffer_push(r, &x, 1);   ret[0] = x;    for (size_t i = 1; i < nstep; ++i) {     x = step_x(r, x);     ring_buffer_push(r, &x, 1);     ret[i] = x;   }    // Cleanup:   ring_buffer_destroy(r); }  int step_x(ring_buffer *r, int x) {   size_t n = ring_buffer_used(r, false);   double p;   if (n < 2) {     p = 0.5;   } else {     // Oldest non-overflowed element is in the tail.  Note that the     // return value (which is void*) must be first cast to (int*) then     // dereferenced.     ///     // NOTE: In general, check that the return value here is not NULL     // (indicating an underflow); here we're OK because we checked the     // number of used elements at the beginning.     int x0 = *(int*)ring_buffer_tail(r);     size_t increases = 0;     for (size_t i = 1; i < n; ++i) {       // Moving through the more recently added elements:       int x1 = *(int*)ring_buffer_tail_offset(r, i);       if (x1 > x0) {         increases++;       }       x0 = x1;     }     p = ((double)increases) / (n - 1);   }    if (unif_rand() < p) {     --x;   } else {     ++x;   }    return x; }  // This function collects all the R API bits that deal with // communication between C and R.  \"Writing R extensions\" is the // canonical documentation source. SEXP r_example(SEXP r_nstep) {   size_t nstep = (size_t) INTEGER(r_nstep)[0];   SEXP ret = PROTECT(allocVector(REALSXP, nstep));   GetRNGstate(); // because we'll work with random numbers   example(nstep, REAL(ret));   // Cleanup:   PutRNGstate();   UNPROTECT(1);   return ret; }  // This can be included in a different file, or, for a single file // project like this one, include here. #include <ring/ring.c>"},{"path":"https://mrc-ide.github.io/ring/articles/ring.html","id":"a-nontrivial-example","dir":"Articles","previous_headings":"The C API","what":"A nontrivial example","title":"ring","text":"dde package (yet CRAN), use ring buffers solve delay differential equations (DDEs). solve , need know state system series points past. every time step push state system onto ring buffer. , solver moves forward time can get system previous point time looking back ring buffer time question found. application ring buffer ideal data structure often want solve equations time look back small fraction total time. Without ring buffer ’d either store entire history (large memory cost, needed) periodically copy history around. use ring within dde package: DESCRIPTION declare link ring using LinkingTo: field. src directory, contents <ring/ring.c> included; possible LinkingTo field. file now includes actual ring buffer implementation. src/dopri.h include <ring/ring.h> allows ring buffer code used file includes dopri.h. data structure header includes within ring buffer hold history. src/dopri.c ring buffer code actually used: initialisation time found within ring buffer ring buffer advanced data freed src/dopri_5.c new data written head ring buffer, state system end step. history head treated big block contiguous doubles. Used way, programmer can focus simply writing application little work bookkeeping possible.","code":""},{"path":"https://mrc-ide.github.io/ring/articles/ring.html","id":"the-c-api-1","dir":"Articles","previous_headings":"","what":"The C++ API","title":"ring","text":"’re using C++ may find Boost circular buffer likely far better; can use LinkingTo: BH package using #include <boost/circular_buffer.hpp> code. Alternatively, ring C code can directly used C++ . , class-based approach available: src/ directory, add file ring.cpp containing just line #include <ring/ring.cpp> Anywhere code want use ring buffer, include line #include <dde/dde.hpp> include class definition:","code":"#ifndef _RING_HPP_ #define _RING_HPP_  // NOTE: the C++ version always uses non-R memory allocation functions // because otherwise the R error can jump over destructors causing // memory leaks or worse.  Errors will be thrown with \"throw\", which // Rcpp will catch if you use that. // // However, note that if using overflow_action of anything other than // OVERFLOW_OVERWRITE is possibly unsafe; OVERFLOW_GROW is fine so // long as you never run out of memory, and OVERFLOW_ERROR is probably // never safe. #define RING_USE_STDLIB_ALLOC 1 #include <ring/ring.h>  class RingBuffer {   ring_buffer * buffer; public:   RingBuffer(size_t size, size_t stride, overflow_action on_overflow);   ~RingBuffer();   RingBuffer(const RingBuffer& other);   RingBuffer& operator=(RingBuffer other);    void grow(size_t n, bool exact);   void reset(bool clear);   size_t size(bool bytes) const;   size_t free(bool bytes) const;   size_t used(bool bytes) const;   size_t bytes_data() const;   bool is_full() const;   bool is_empty() const;   const void * data() const;   const void * head() const;   const void * tail() const;   size_t head_pos(bool bytes) const;   size_t tail_pos(bool bytes) const;   size_t set(data_t c, size_t len);   size_t set_stride(const void *x, size_t len);   const void * push(const void *src, size_t n);   const void * take(void *dest, size_t n);   const void * read(void *dest, size_t n) const;   const void * copy(RingBuffer& dest, size_t n);   bool mirror(RingBuffer& dest) const;   const void * tail_offset(size_t offset) const;   const void * head_offset(size_t offset) const; };  #endif"},{"path":"https://mrc-ide.github.io/ring/articles/ring_applications.html","id":"ring-vector","dir":"Articles","previous_headings":"","what":"Ring vector","title":"ring applications","text":"actual code buffer available package via system.file(\"examples/ring_vector.R\", package = \"ring\") (path depends R package installations). create integer ring vector length 5: Convert back R vector (involves copy) add things vector, use push generic: can push multiple items : Random read access works: Resetting buffer zeros : Returning simulation example main vignette: whole history: last 5 steps: Now, rewriting , time step function taking buffer . simplifies implementation, details handled S3 methods length, push [.","code":"## Simulate an atomic vector or matrix with a ring buffer.  These ## functions exist mostly as an example of use of a ring buffer ## designed to work with R functions that do not know (or care) that ## the object is implemented with a ring buffer behind the scenes. ## Elements will be added at the end of the vector and taken from the ## beginning. ## ## Note that because the matrix is stored row-wise but R stores ## matrices column wise, there is a lot of data transposing going on ## here.  If something like this was needed for performance then ## you'd want to redo this with column storage. ## ## The `push` function is generic and can be used to push ## elements onto either a `ring_vector` or a `ring_matrix`. ## ## Note that these are implemented more as proof-of-concepts rather ## than really robust data types. ## ## * `length_max`: The maximum number of elements ## * `type`: The type of storage.  Can be \"logical\", \"integer\", ##   \"double\", or \"complex\" ## * `environment`: Logical indicating if we should use an environment ##   buffer (`ring_buffer_env`) or a bytes buffer ##   (`ring_buffer_bytes`). ring_vector <- function(length_max, type, environment = TRUE) {   type <- match.arg(type, names(create))   if (environment) {     buf <- ring::ring_buffer_env(length_max)   } else {     buf <- ring::ring_buffer_bytes_typed(length_max, type, 1L)   }   ret <- list(buf = buf, length_max = as.integer(length_max),               type = type, environment = environment)   class(ret) <- \"ring_vector\"   ret }  ring_vector_push <- function(buffer, data, check = TRUE, ...) {   if (check) {     ring_vector_compatible(buffer, data)   }   buffer$buf$push(data) }  ring_vector_compatible <- function(x, data) {   if (storage.mode(data) != x$type) {     stop(\"Expected storage.mode of \", x$type)   }   TRUE }  ring_vector_get <- function(x, i = NULL) {   if (is.null(i)) {     ret <- x$buf$read(x$buf$used())     if (x$environment) {       if (length(ret) == 0L) {         ret <- create[[x$type]]()       } else {         ret <- unlist(ret)       }     }   } else {     len <- x$buf$used()     i <- ring_vector_index(i, len)     ret <- create[[x$type]](length(i))     for (j in seq_along(i)) {       k <- i[[j]]       ret[j] <- if (k <= len) x$buf$tail_offset(k - 1L) else NA     }   }    ret }  ring_vector_index <- function(i, len) {   if (is.logical(i)) {     if (length(i) < len) {       i <- rep_len(i, len)     }     i <- which(i)   } else if (!is.numeric(i)) {     stop(\"Invalid type for index\")   } else if (any(i < 0)) {     i <- seq_len(len)[i]   }   i }  ## S3 support: push <- function(buffer, data, ...) {   UseMethod(\"push\") }  push.ring_vector <- ring_vector_push  length.ring_vector <- function(x, ...) {   x$buf$used() }  `[[.ring_vector` <- `[.ring_vector` <- function(x, i, ...) {   if (missing(i)) {     ring_vector_get(x, NULL)   } else {     ring_vector_get(x, i)   } }  c.ring_vector <- function(..., recursive = TRUE) {   if (!inherits(..1, \"ring_vector\")) {     args <- list(...)     i <- vapply(args, inherits, logical(1), \"ring_vector\")     args[i] <- lapply(args[i], as.matrix)     eval(as.call(c(quote(rbind), args)))   } else {     x <- ..1     args <- list(...)[-1]     lapply(args, ring_vector_compatible, x = x)     for (m in args) {       ring_vector_push(x, m)     }     x   } }  ## Support functions; these are functions used to create empty storage ## for the bytes buffers create <- list(logical = logical,                integer = integer,                double = double,                complex = complex)  registerS3method(\"[\", \"ring_vector\", `[.ring_vector`, environment()) registerS3method(\"[[\", \"ring_vector\", `[[.ring_vector`, environment()) registerS3method(\"length\", \"ring_vector\", length.ring_vector, environment()) registerS3method(\"c\", \"ring_vector\", c.ring_vector, environment()) v <- ring_vector(5, \"integer\", FALSE) v[] ## integer(0) push(v, 1L) v[] ## [1] 1 push(v, 2:4) v[] ## [1] 1 2 3 4 length(v) ## [1] 4 v[3] ## [1] 3 v[[1]] ## [1] 1 v$buf$reset() ## NULL length(v) ## [1] 0 buf <- ring_vector(5, \"integer\", FALSE) h <- integer(20) x <- 0L push(buf, x) h[1L] <- x  step <- function(x) {   if (runif(1) < 0.5) x - 1L else x + 1L }  set.seed(1) for (i in seq_len(length(h) - 1L)) {   x <- step(x)   push(buf, x)   h[i + 1L] <- x } h ##  [1]  0 -1 -2 -1  0 -1  0  1  2  3  2  1  0  1  0  1  0  1  2  1 buf[] ## [1] 1 0 1 2 1 step <- function(x) {   if (length(x) > 1) {     p <- mean(diff(x[])) / 2 + 0.5   } else {     p <- 0.5   }   if (runif(1) < p) x[length(x)] - 1L else x[length(x)] + 1L }  buf <- ring_vector(5, \"integer\", FALSE) h <- integer(100) x <- 0L  push(buf, x) h[1L] <- x  set.seed(1) for (i in seq_len(length(h) - 1L)) {   x <- step(buf)   push(buf, x)   h[i + 1L] <- x }  par(mar=c(4, 4, .5, .5)) plot(h, type=\"l\", xlab=\"step\", ylab=\"y\", las=1)"},{"path":"https://mrc-ide.github.io/ring/articles/ring_applications.html","id":"ring-matrix-with-ring_matrix","dir":"Articles","previous_headings":"","what":"Ring matrix with ring_matrix","title":"ring applications","text":"ring_matrix data structure generalises ring_vector; buffer looks R like matrix grows adding rows bottom shrinks consuming rows top. even contrived , consider simultaneously simulating movement n random particles reflecting random walk . First create 10 x 5 ring matrix: current state matrix : can set initial state :","code":"## * `nr_max`: The maximum number of rows ## * `nc`: The number of columns in the matrix ring_matrix <- function(nr_max, nc, type, environment = TRUE) {   type <- match.arg(type, names(ring:::sizes))   if (environment) {     buf <- ring::ring_buffer_env(nr_max)   } else {     buf <- ring::ring_buffer_bytes_typed(nr_max, type, nc)   }   ret <- list(buf = buf, nr_max = as.integer(nr_max), nc = as.integer(nc),               type = type, environment = environment)   class(ret) <- \"ring_matrix\"   ret }  ring_matrix_push <- function(buffer, data, check = TRUE, ...) {   if (check) {     ring_matrix_compatible(buffer, data)   }   if (buffer$environment) {     if (is.matrix(data)) {       for (i in seq_len(nrow(data))) {         buffer$buf$push(data[i, ], FALSE)       }     } else {       buffer$buf$push(data, FALSE)     }   } else {     buffer$buf$push(if (is.matrix(data)) t(data) else data)   } }  ring_matrix_compatible <- function(x, data) {   if (storage.mode(data) != x$type) {     stop(\"Expected storage.mode of \", x$type)   }   if (is.matrix(data)) {     if (ncol(data) != x$nc) {       stop(sprintf(\"Expected a matrix of '%d' columns\", x$nc))     }   } else {     if (length(data) != x$nc) {       stop(sprintf(\"Expected a matrix of '%d' columns\", x$nc))     }   }   TRUE }  ring_matrix_get <- function(x, i = NULL) {   if (is.null(i)) {     dat <- x$buf$read(x$buf$used())     if (x$environment) {       if (length(dat) == 0L) {         dat <- create[[x$type]]()       } else {         dat <- unlist(dat)       }     }     ret <- matrix(dat, ncol = x$nc, byrow = TRUE)   } else {     len <- x$buf$used()     i <- ring_vector_index(i, len)     ret <- matrix(create[[x$type]](length(i) * x$nc), length(i), x$nc)     for (j in seq_along(i)) {       k <- i[[j]]       ret[j, ] <- if (k <= len) x$buf$tail_offset(k - 1L) else NA     }   }    if (!is.null(x$colnames)) {     colnames(ret) <- x$colnames   }    ret }  ## S3 support push.ring_matrix <- ring_matrix_push  dim.ring_matrix <- function(x, ...) {   c(x$buf$used(), x$nc) }  head.ring_matrix <- function(x, n = 6L, ...) {   head.matrix(x, n, ...) }  tail.ring_matrix <- function(x, n = 6L, ...) {   tail.matrix(x, n, FALSE, ...) }  `[.ring_matrix` <- function(x, i, j, ..., drop = TRUE) {   if (missing(i)) {     if (missing(j)) {       ring_matrix_get(x, NULL)     } else {       ring_matrix_get(x, NULL)[, j, drop = drop]     }   } else if (is.matrix(i)) {     if (!missing(j)) {       stop(\"subscript out of bounds\") # same error as [.matrix     }     j <- sort(unique(i[, 1L]))     ring_matrix_get(x, j)[cbind(match(i[, 1L], j), i[, 2L])]   } else {     ring_matrix_get(x, i)[, j, drop = drop]   } }  dimnames.ring_matrix <- function(x, ...) {   if (is.null(x$colnames)) {     NULL   } else {     list(NULL, x$colnames)   } }  `dimnames<-.ring_matrix` <- function(x, value) {   if (is.null(value)) {     x$colnames <- NULL   } else if (!is.list(value) || length(value) != 2L) {     stop(\"Invalid input for dimnames\")   } else {     if (!is.null(value[[1L]])) {       stop(\"Cannot set rownames of a ring matrix\")     }     val <- value[[2L]]     if (!is.null(val) && length(val) != x$nc) {       stop(\"Invalid length dimnames\")     }     x$colnames <- val   }   x }  as.matrix.ring_matrix <- function(x, ...) {   ring_matrix_get(x, NULL) }  cbind.ring_matrix <- function(...) {   stop(\"It is not possible to cbind() ring_matrices (use as.matrix first?)\") }  rbind.ring_matrix <- function(...) {   if (!inherits(..1, \"ring_matrix\")) {     args <- list(...)     i <- vapply(args, inherits, logical(1), \"ring_matrix\")     args[i] <- lapply(args[i], as.matrix)     eval(as.call(c(quote(rbind), args)))   } else {     x <- ..1     args <- list(...)[-1]     lapply(args, ring_matrix_compatible, x = x)     for (m in args) {       ring_matrix_push(x, m)     }     x   } }  length.ring_matrix <- function(x) {   x$buf$used() * x$nc }  registerS3method(\"[\", \"ring_matrix\", `[.ring_matrix`, environment()) registerS3method(\"dim\", \"ring_matrix\", dim.ring_matrix, environment()) registerS3method(\"dimnames\", \"ring_matrix\", dimnames.ring_matrix, environment()) registerS3method(\"dimnames<-\", \"ring_matrix\", `dimnames<-.ring_matrix`,                  environment()) registerS3method(\"as.matrix\", \"ring_matrix\", cbind.ring_matrix, environment()) registerS3method(\"cbind\", \"ring_matrix\", cbind.ring_matrix, environment()) registerS3method(\"rbind\", \"ring_matrix\", rbind.ring_matrix, environment()) n <- 10 m <- ring_matrix(5, n, \"integer\", FALSE) m[] ##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] push(m, matrix(0L, 1, n)) m[] ##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] ## [1,]    0    0    0    0    0    0    0    0    0     0 step <- function(m) {   if (nrow(m) > 1) {     p <- colMeans(diff(m[])) / 2 + 0.5   } else {     p <- rep(0.5, ncol(m))   }   m[nrow(m), ] + as.integer(ifelse(runif(length(p)) < p, -1, 1L)) }  m <- ring_matrix(5, n, \"integer\", FALSE) x <- rep(0L, n) push(m, x)  h <- matrix(NA, 200, n) h[1, ] <- x set.seed(1) for (i in seq_len(nrow(h) - 1L)) {   x <- step(m)   push(m, x)   h[i + 1L, ] <- x }  par(mar=c(4, 4, .5, .5)) matplot(h, type=\"l\", lty=1, las=1)"},{"path":"https://mrc-ide.github.io/ring/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Rich FitzJohn. Author, maintainer. Imperial College Science, Technology Medicine. Copyright holder.","code":""},{"path":"https://mrc-ide.github.io/ring/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"FitzJohn R (2024). ring: Circular / Ring Buffers. R package version 1.0.7, https://github.com/mrc-ide/ring, https://mrc-ide.gitub.io/ring.","code":"@Manual{,   title = {ring: Circular / Ring Buffers},   author = {Rich FitzJohn},   year = {2024},   note = {R package version 1.0.7, https://github.com/mrc-ide/ring},   url = {https://mrc-ide.gitub.io/ring}, }"},{"path":"https://mrc-ide.github.io/ring/index.html","id":"ring","dir":"","previous_headings":"","what":"Circular / Ring Buffers","title":"Circular / Ring Buffers","text":"Ring buffers R C Ring buffers (circular buffers) like arrays seem circular; data written read first--first-(FIFO) style, allocated subsequent writes cause memory allocations. Circular buffers useful collecting processing data streams queues (fixed maximum size). use implement solver delay differential equations dde. package provides two implementations ring buffers: ring_buffer_env: pure R ring buffer implemented double linked list (using environments) genuinely ring. ring_buffer_bytes: ring buffer implemented array bytes pair pointers (C). “element” array can one bytes, must fixed size. two convenience interfaces: ring_buffer_bytes_translate: cases raw->R R->raw translation functions provided ring_buffer_bytes_typed cases element correspond fixed-length vector one R’s core numeric-ish types (logical, integer, numeric, complex) buffer types can used R, code underlying ring_buffer_bytes can also used compiled code packages using R’s LinkingTo: support. common set methods provided, though differ details. buffer types refuse underflow (return elements beyond written). behaviour overflow can controlled: overwrite old data: (default), fixed-memory FIFO buffer grow buffer: expand buffer geometrically fit required elements (require additional memory allocations copies) throw error: refuse overflow Depending application, ring buffers may may faster manually copying data around vectors. benefit package rather hand abstracting away lot subtle bookkeeping keeping interface fairly high level. However, C applications, using ring_buffer_bytes via C interface (using LinkingTo) likely fast avoids copies. See reference documentation details.","code":""},{"path":"https://mrc-ide.github.io/ring/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Circular / Ring Buffers","text":"main package vignette (vignette(\"ring\")) contains introduction basic usage. second vignette (vignette(\"ring_applications\")) describes possible data structures using ring buffer. reference documentation also available online, package.","code":""},{"path":"https://mrc-ide.github.io/ring/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Circular / Ring Buffers","text":"MIT © Imperial College Science, Technology Medicine Please note project released Contributor Code Conduct. participating project agree abide terms.","code":""},{"path":"https://mrc-ide.github.io/ring/reference/ring_buffer_bytes.html","id":null,"dir":"Reference","previous_headings":"","what":"Byte array based ring buffer — ring_buffer_bytes","title":"Byte array based ring buffer — ring_buffer_bytes","text":"Construct ring buffer buffer holds stream bytes. Optionally, buffer can \"strided\" bytes naturally fall chunks exactly size.  implemented C hope fast, limitation data transfer R always involve copies.","code":""},{"path":"https://mrc-ide.github.io/ring/reference/ring_buffer_bytes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Byte array based ring buffer — ring_buffer_bytes","text":"","code":"ring_buffer_bytes(size, stride = 1L, on_overflow = \"overwrite\")"},{"path":"https://mrc-ide.github.io/ring/reference/ring_buffer_bytes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Byte array based ring buffer — ring_buffer_bytes","text":"size Number elements buffer, stride bytes long. stride Number bytes per buffer element.  Defaults 1 byte.  want store anything bytestream buffer, probably want one byte per element; example, R platforms integer takes 4 bytes double takes 8 (see .Machine, also ring_buffer_bytes_typed). on_overflow Behaviour buffer overflow.  default overwrite oldest elements buffer (\"overwrite\").  Alternative actions \"error\" throw error function tries add elements space , \"grow\" grow buffer accept new elements (uses approximately golden ratio approach; see details ).","code":""},{"path":"https://mrc-ide.github.io/ring/reference/ring_buffer_bytes.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Byte array based ring buffer — ring_buffer_bytes","text":"contrast ring_buffer_env, every element buffer size; makes less flexible (decide ahead time storing), time can make using buffer easier think (decided ahead time storing). want use store fixed-size arrays integers, numerics, etc, see ring_buffer_bytes_typed wraps fast conversion functions. on_overflow action \"grow\" buffer overflows, size buffer grow geometrically (also case manually $grow() buffer exact = FALSE.  used way, let n number additional elements space needed ; ring looks total needed capacity (used plus n relative size()).  buffer needs made larger fit n elements grown factor phi (golden ratio, approximately 1.6). fit n elements buffer needs increased size m smallest size * phi, size * phi^2, size * phi^3, ... used new size. contrast, using grow() method exact = TRUE always increase size buffer long n positive.","code":""},{"path":"https://mrc-ide.github.io/ring/reference/ring_buffer_bytes.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Byte array based ring buffer — ring_buffer_bytes","text":"Note methods reference section repeated verbatim three main ring buffer classes; ring_buffer_env (\"env\"), ring_buffer_bytes (\"bytes\") ring_buffer_bytes_typed (\"typed\").  Almost methods arguments behaviour, hopefully listing everything together, differences implementations bit apparent. reset Reset state buffer.  \"zeros\" head tail pointer (may may actually reset data) buffer can used fresh. Usage: reset(clear = FALSE) Arguments: clear:   Logical, indicating memory also cleared. Generally necessary, environment buffers can let garbage collector clean large elements.  bytes buffer zeros memory. Return value: Nothing; called side effect . duplicate Clone ring buffer, creating copy.  Copies underlying data position head tail. Usage: duplicate() Return value: new ring buffer object grow Increase size buffer n elements. Usage: bytes, typed: grow(n) env: grow(n, exact = FALSE) Arguments: n:   number additional elements space reserved (scalar non-negative integer).   Return value: Nothing; called side effect . size Return capacity (maximum size) ring buffer Usage: env: size() bytes, typed: size(bytes = FALSE) Arguments: bytes:   (ring_buffer_bytes ) Logical, indicating size returned bytes (rather logical entries, default). Return value: scalar integer bytes_data Return total size data storage used object. Usage: env: (supported) bytes, typed: bytes_data() Return value: scalar integer stride Length element ring buffer, bytes.  implemented (meaningful) bytes buffer; environment buffer support function makes sense . Usage: env: (supported) bytes, typed: stride() Return value: scalar integer used Return amount space used ring buffer. Usage: env: used() bytes, typed: used(bytes = FALSE) Arguments: bytes:   (ring_buffer_bytes ) Logical, indicating size returned bytes (rather logical entries, default). Return value: scalar integer free Return amount space free ring buffer. Usage: env: free() bytes, typed: free(bytes = FALSE) Arguments: bytes:   (ring_buffer_bytes ) Logical, indicating size returned bytes (rather logical entries, default). Return value: scalar integer is_empty Test ring buffer empty Usage: is_empty() Return value: scalar logical is_full Test ring buffer full Usage: is_full() Return value: scalar logical head_pos Return number entries \"start\" ring buffer head .  mostly useful debugging. Usage: env: head_pos() bytes, typed: head_pos(bytes = FALSE) Arguments: bytes:   (ring_buffer_bytes ) Logical, indicating position returned bytes (rather logical entries, default). Return value: scalar integer tail_pos Return number entries \"start\" ring buffer tail .  mostly useful debugging. Usage: env: tail_pos() bytes, typed: tail_pos(bytes = FALSE) Arguments: bytes:   (ring_buffer_bytes ) Logical, indicating position returned bytes (rather logical entries, default). Return value: scalar integer head Return contents head (recently written element ring buffer). Usage: head() Return value: depends little .  ring_buffer_env single R object.  ring_buffer_bytes raw vector, length stride ring buffer.  ring_buffer_bytes_typed, single R object translated raw. tail Return contents tail (least recently written element ring buffer). Usage: tail() Return value: head set Set number ring entries value.  exact behaviour varies depending type ring buffer.  function may overflow ring buffer; case tail moved. Usage: set(data, n) Arguments: data:   data set ring element .  environment buffer, may R object.  bytes buffer may either single byte (case ring element set byte, repeated stride times), raw vector length stride.   Return value: Invisibly returns number elements actually written (may less n buffer overflows).  Primarily called side effect. push Push elements onto ring buffer head.  may overflow ring buffer, destroying oldest elements buffer (moving position tail). Usage: env: push(data, iterate = TRUE) bytes, typed: push(data) Arguments: data:   Data push onto ring buffer.  ring_buffer_bytes, must raw vector length multiple buffer stride.  ring_buffer_bytes_typed must vector appropriate type.  ring_buffer_env may arbitrary R object (see iterate .   Return value: ring_buffer_bytes, data invisibly.  ring_buffer_bytes ring_buffer_bytes_typed, position head pointer (relative beginning storage region). take Destructively take elements ring buffer.  consumes tail (least recently added elements).  possibly underflow buffer; elements requested can supplied error thrown state buffer unmodified. Usage: take(n) Arguments: n:   number elements take. Return value: ring_buffer_env list n elements. ring_buffer_bytes, raw vector n * stride bytes.  ring_buffer_bytes_typed, vector n elements storage mode ring. read Nondestructively read elements ring buffer.  identical take except state buffer modified. Usage: read(n) Arguments: n:   number elements read. Return value: ring_buffer_env list n elements. ring_buffer_bytes, raw vector n * stride bytes.  ring_buffer_bytes_typed, vector n elements storage mode ring. copy Copy ring buffer different ring buffer. destructive respect ring buffers; tail pointer moved ring buffer data taken, destination ring buffer overflows, tail pointer moved . Usage: copy(dest, n) Arguments: dest:   destination ring buffer - modified call.   mirror Mirror contents ring buffer different ring buffer.  differs copy ring buffer unaffected ring buffer copied (including head/tail positions).  provides alternative way duplicating state duplicate already appropriately sized ring buffer handy.  allocations done. Usage: mirror(dest) Arguments: dest:   destination ring buffer - modified call. Return value: Nothing; called side effect . head_offset Nondestructively read contents head buffer, offset n entries. Usage: head_offset(n) Arguments: n:   Head offset.  moves away recently added item. offset 0 reads recently added element, 1 reads element added . Return value: head tail_offset Nondestructively read contents tail buffer, offset n entries. Usage: tail_offset(n) Arguments: n:   Tail offset.  moves away oldest item.  offset 0 reads oldest element, 1 reads element added . Return value: tail (see head) take_head take, operating head rather tail.  destructive respect head. Usage: take_head(n) Arguments: n:   Number elements take. Return value: take read_head read, operating head rather tail.  destructive respect tail. Usage: read_head(n) Arguments: n:   Number elements read. Return value: read head_set Set data head without advancing.  useful cases head data set advanced separately (head_advance).  unlikely useful users.  used extensively dde (called C). Usage: head_set(data) Arguments: data:   Data set head.  bytes buffer must exactly stride bytes long, environment buffer corresponds single \"element\". Return value: Nothing; called side effect . head_data Retrieve current data stored head advanced. many cases may junk - byte buffer looped bytes overwritten next write.  However, using head_set data set buffer yet committed head_advance. Usage: head_data() Return value: head head_advance Shift head around one position.  commits data written head_set. Usage: head_advance() Return value: Nothing; called side effect .","code":"\\item{\\code{exact}:   (For bytes buffer only) Logical scalar indicating if growth should increase the size by \\emph{exactly} \\code{n} elements (if \\code{TRUE}) or so that \\emph{at least} \\code{n} additional elements will fit (growing the buffer geometrically if needed). } \\item{\\code{n}:   The number of entries to set to \\code{data} } \\item{\\code{iterate}:   For \\code{ring_buffer_env} only, changes the behaviour with vectors and lists.  Because each element of a \\code{ring_buffer_env} can b an arbitrary R object, for a list \\code{x} it is ambiguous if \\code{push(x)} should push one object onto the buffer, or \\code{length(x)} objects (i.e. equivalent to \\code{push(x[[1]])}, \\code{push(x[[2]])}, etc.  The \\code{iterate} argument switches between interpretations; if \\code{TRUE} (the default) the push will iterate over the object using \\code{for (el in x)} (with appropriate S3 dispatch).  If \\code{iterate = FALSE}, then the entire object is pushed at once, so always updating only by a single element. } \\item{\\code{n}:   The number of elements to copy }"},{"path":"https://mrc-ide.github.io/ring/reference/ring_buffer_bytes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Byte array based ring buffer — ring_buffer_bytes","text":"","code":"# Create a ring buffer of 100 bytes b <- ring_buffer_bytes(100)  # Get the length, number of used and number of free bytes: b$size() #> [1] 100 b$used() #> [1] 0 b$free() #> [1] 100  # Nothing is used because we're empty: b$is_empty() #> [1] TRUE  # To work with a bytes buffer you need to use R's raw vectors; # here are 30 random bytes: bytes <- as.raw(as.integer(sample(256, 30, TRUE) - 1L)) bytes #>  [1] ac 96 cb 3e e4 65 6e 2e 9e c3 e5 c8 c4 04 fe 17 4e 4c 81 bd 36 aa 3d 2a 04 #> [26] d4 2b bc 21 45  # Push these onto the bytes buffer: b$push(bytes) b$used() #> [1] 30  # The head of the buffer points at the most recently added item b$head() #> [1] 45 bytes[[length(bytes)]] #> [1] 45  # ...and the tail at the oldest (first added in this case) b$tail() #> [1] ac bytes[[1]] #> [1] ac  # Elements are taken from the tail; these will be the oldest items: b$take(8) #> [1] ac 96 cb 3e e4 65 6e 2e bytes[1:8] #> [1] ac 96 cb 3e e4 65 6e 2e b$used() #> [1] 22  # To read from the buffer without removing elements, use read: b$read(8) #> [1] 9e c3 e5 c8 c4 04 fe 17 bytes[9:16] #> [1] 9e c3 e5 c8 c4 04 fe 17  # It is not possible to take or read more elements than are # present in the buffer; it will throw an error: if (FALSE) { # \\dontrun{ b$read(50) # error because there are only 22 bytes present } # }  # More elements can be pushed on: b$push(as.raw(rep(0, 50))) b$used() #> [1] 72 b$read(b$used()) #>  [1] 9e c3 e5 c8 c4 04 fe 17 4e 4c 81 bd 36 aa 3d 2a 04 d4 2b bc 21 45 00 00 00 #> [26] 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 #> [51] 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  # If many new elements are added, they will displace the old elements: b$push(as.raw(1:75)) b$read(b$used()) #>   [1] 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 #>  [26] 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17 18 19 #>  [51] 1a 1b 1c 1d 1e 1f 20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f 30 31 32 #>  [76] 33 34 35 36 37 38 39 3a 3b 3c 3d 3e 3f 40 41 42 43 44 45 46 47 48 49 4a 4b"},{"path":"https://mrc-ide.github.io/ring/reference/ring_buffer_bytes_translate.html","id":null,"dir":"Reference","previous_headings":"","what":"Translating bytes ring buffer — ring_buffer_bytes_translate","title":"Translating bytes ring buffer — ring_buffer_bytes_translate","text":"ring buffer based ring_buffer_bytes performs conversion /bytes something useful data stored/retrieved buffer.  interface ring_buffer_bytes_typed implemented.","code":""},{"path":"https://mrc-ide.github.io/ring/reference/ring_buffer_bytes_translate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Translating bytes ring buffer — ring_buffer_bytes_translate","text":"","code":"ring_buffer_bytes_translate(size, stride, to, from, on_overflow = \"overwrite\")"},{"path":"https://mrc-ide.github.io/ring/reference/ring_buffer_bytes_translate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Translating bytes ring buffer — ring_buffer_bytes_translate","text":"size Number elements buffer, stride bytes long. stride Number bytes per buffer element.  Defaults 1 byte.  want store anything bytestream buffer, probably want one byte per element; example, R platforms integer takes 4 bytes double takes 8 (see .Machine, also ring_buffer_bytes_typed). Function convert R object set exactly stride bytes.  must take one argument (R object) return raw vector length multiple stride (including zero).  may throw error possible convert object bytes vector. Function convert set bytes R object.  must take one argument (raw vector length multiple stride, including zero).  throw error data added buffer passed way buffer. on_overflow Behaviour buffer overflow.  default overwrite oldest elements buffer (\"overwrite\").  Alternative actions \"error\" throw error function tries add elements space , \"grow\" grow buffer accept new elements (uses approximately golden ratio approach; see details ).","code":""},{"path":"https://mrc-ide.github.io/ring/reference/ring_buffer_bytes_translate.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Translating bytes ring buffer — ring_buffer_bytes_translate","text":"idea manually working raw vectors can get tedious, planning using bytes-based buffer working R may way conversion R objects.  interface lets specify functions apply conversion function every case needed.","code":""},{"path":"https://mrc-ide.github.io/ring/reference/ring_buffer_bytes_translate.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Translating bytes ring buffer — ring_buffer_bytes_translate","text":"Note methods reference section repeated verbatim three main ring buffer classes; ring_buffer_env (\"env\"), ring_buffer_bytes (\"bytes\") ring_buffer_bytes_typed (\"typed\").  Almost methods arguments behaviour, hopefully listing everything together, differences implementations bit apparent. reset Reset state buffer.  \"zeros\" head tail pointer (may may actually reset data) buffer can used fresh. Usage: reset(clear = FALSE) Arguments: clear:   Logical, indicating memory also cleared. Generally necessary, environment buffers can let garbage collector clean large elements.  bytes buffer zeros memory. Return value: Nothing; called side effect . duplicate Clone ring buffer, creating copy.  Copies underlying data position head tail. Usage: duplicate() Return value: new ring buffer object grow Increase size buffer n elements. Usage: bytes, typed: grow(n) env: grow(n, exact = FALSE) Arguments: n:   number additional elements space reserved (scalar non-negative integer).   Return value: Nothing; called side effect . size Return capacity (maximum size) ring buffer Usage: env: size() bytes, typed: size(bytes = FALSE) Arguments: bytes:   (ring_buffer_bytes ) Logical, indicating size returned bytes (rather logical entries, default). Return value: scalar integer bytes_data Return total size data storage used object. Usage: env: (supported) bytes, typed: bytes_data() Return value: scalar integer stride Length element ring buffer, bytes.  implemented (meaningful) bytes buffer; environment buffer support function makes sense . Usage: env: (supported) bytes, typed: stride() Return value: scalar integer used Return amount space used ring buffer. Usage: env: used() bytes, typed: used(bytes = FALSE) Arguments: bytes:   (ring_buffer_bytes ) Logical, indicating size returned bytes (rather logical entries, default). Return value: scalar integer free Return amount space free ring buffer. Usage: env: free() bytes, typed: free(bytes = FALSE) Arguments: bytes:   (ring_buffer_bytes ) Logical, indicating size returned bytes (rather logical entries, default). Return value: scalar integer is_empty Test ring buffer empty Usage: is_empty() Return value: scalar logical is_full Test ring buffer full Usage: is_full() Return value: scalar logical head_pos Return number entries \"start\" ring buffer head .  mostly useful debugging. Usage: env: head_pos() bytes, typed: head_pos(bytes = FALSE) Arguments: bytes:   (ring_buffer_bytes ) Logical, indicating position returned bytes (rather logical entries, default). Return value: scalar integer tail_pos Return number entries \"start\" ring buffer tail .  mostly useful debugging. Usage: env: tail_pos() bytes, typed: tail_pos(bytes = FALSE) Arguments: bytes:   (ring_buffer_bytes ) Logical, indicating position returned bytes (rather logical entries, default). Return value: scalar integer head Return contents head (recently written element ring buffer). Usage: head() Return value: depends little .  ring_buffer_env single R object.  ring_buffer_bytes raw vector, length stride ring buffer.  ring_buffer_bytes_typed, single R object translated raw. tail Return contents tail (least recently written element ring buffer). Usage: tail() Return value: head set Set number ring entries value.  exact behaviour varies depending type ring buffer.  function may overflow ring buffer; case tail moved. Usage: set(data, n) Arguments: data:   data set ring element .  environment buffer, may R object.  bytes buffer may either single byte (case ring element set byte, repeated stride times), raw vector length stride.   Return value: Invisibly returns number elements actually written (may less n buffer overflows).  Primarily called side effect. push Push elements onto ring buffer head.  may overflow ring buffer, destroying oldest elements buffer (moving position tail). Usage: env: push(data, iterate = TRUE) bytes, typed: push(data) Arguments: data:   Data push onto ring buffer.  ring_buffer_bytes, must raw vector length multiple buffer stride.  ring_buffer_bytes_typed must vector appropriate type.  ring_buffer_env may arbitrary R object (see iterate .   Return value: ring_buffer_bytes, data invisibly.  ring_buffer_bytes ring_buffer_bytes_typed, position head pointer (relative beginning storage region). take Destructively take elements ring buffer.  consumes tail (least recently added elements).  possibly underflow buffer; elements requested can supplied error thrown state buffer unmodified. Usage: take(n) Arguments: n:   number elements take. Return value: ring_buffer_env list n elements. ring_buffer_bytes, raw vector n * stride bytes.  ring_buffer_bytes_typed, vector n elements storage mode ring. read Nondestructively read elements ring buffer.  identical take except state buffer modified. Usage: read(n) Arguments: n:   number elements read. Return value: ring_buffer_env list n elements. ring_buffer_bytes, raw vector n * stride bytes.  ring_buffer_bytes_typed, vector n elements storage mode ring. copy Copy ring buffer different ring buffer. destructive respect ring buffers; tail pointer moved ring buffer data taken, destination ring buffer overflows, tail pointer moved . Usage: copy(dest, n) Arguments: dest:   destination ring buffer - modified call.   mirror Mirror contents ring buffer different ring buffer.  differs copy ring buffer unaffected ring buffer copied (including head/tail positions).  provides alternative way duplicating state duplicate already appropriately sized ring buffer handy.  allocations done. Usage: mirror(dest) Arguments: dest:   destination ring buffer - modified call. Return value: Nothing; called side effect . head_offset Nondestructively read contents head buffer, offset n entries. Usage: head_offset(n) Arguments: n:   Head offset.  moves away recently added item. offset 0 reads recently added element, 1 reads element added . Return value: head tail_offset Nondestructively read contents tail buffer, offset n entries. Usage: tail_offset(n) Arguments: n:   Tail offset.  moves away oldest item.  offset 0 reads oldest element, 1 reads element added . Return value: tail (see head) take_head take, operating head rather tail.  destructive respect head. Usage: take_head(n) Arguments: n:   Number elements take. Return value: take read_head read, operating head rather tail.  destructive respect tail. Usage: read_head(n) Arguments: n:   Number elements read. Return value: read head_set Set data head without advancing.  useful cases head data set advanced separately (head_advance).  unlikely useful users.  used extensively dde (called C). Usage: head_set(data) Arguments: data:   Data set head.  bytes buffer must exactly stride bytes long, environment buffer corresponds single \"element\". Return value: Nothing; called side effect . head_data Retrieve current data stored head advanced. many cases may junk - byte buffer looped bytes overwritten next write.  However, using head_set data set buffer yet committed head_advance. Usage: head_data() Return value: head head_advance Shift head around one position.  commits data written head_set. Usage: head_advance() Return value: Nothing; called side effect .","code":"\\item{\\code{exact}:   (For bytes buffer only) Logical scalar indicating if growth should increase the size by \\emph{exactly} \\code{n} elements (if \\code{TRUE}) or so that \\emph{at least} \\code{n} additional elements will fit (growing the buffer geometrically if needed). } \\item{\\code{n}:   The number of entries to set to \\code{data} } \\item{\\code{iterate}:   For \\code{ring_buffer_env} only, changes the behaviour with vectors and lists.  Because each element of a \\code{ring_buffer_env} can b an arbitrary R object, for a list \\code{x} it is ambiguous if \\code{push(x)} should push one object onto the buffer, or \\code{length(x)} objects (i.e. equivalent to \\code{push(x[[1]])}, \\code{push(x[[2]])}, etc.  The \\code{iterate} argument switches between interpretations; if \\code{TRUE} (the default) the push will iterate over the object using \\code{for (el in x)} (with appropriate S3 dispatch).  If \\code{iterate = FALSE}, then the entire object is pushed at once, so always updating only by a single element. } \\item{\\code{n}:   The number of elements to copy }"},{"path":"https://mrc-ide.github.io/ring/reference/ring_buffer_bytes_translate.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Translating bytes ring buffer — ring_buffer_bytes_translate","text":"Rich FitzJohn","code":""},{"path":"https://mrc-ide.github.io/ring/reference/ring_buffer_bytes_translate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Translating bytes ring buffer — ring_buffer_bytes_translate","text":"","code":"# The \"typed\" ring buffers do not allow for character vectors to # be stored, because strings are generally hard and have unknown # lengths.  But if you wanted to store strings that are *always* # the same length, this is straightforward to do.  # You can convert from string to bytes with charToRaw (or # as.raw(utf8ToInt(x))): bytes <- charToRaw(\"hello!\") bytes #> [1] 68 65 6c 6c 6f 21  # And back again with rawToChar (or intToUtf8(as.integer(x))) rawToChar(bytes) #> [1] \"hello!\"  # So with these functions we can make a buffer for storing # fixed-length strings: b <- ring_buffer_bytes_translate(100, 8, charToRaw, rawToChar)  # And with this we can store 8 character strings: b$push(\"abcdefgh\") b$tail() #> [1] \"abcdefgh\"  # Other length strings cannot be added: try(   b$push(\"hello!\") ) # error #> Error in super$push(self$.to(data)) :  #>   Incorrect size data; expected multiple of 8 bytes  # Because the 'from' and 'to' arguments can be arbitrary R # functions we could tweak this to pad the character vector with # null bytes, and strip these off on return: char_to_raw <- function(x, max_len) {   if (!(is.character(x) && length(x) == 1L)) {     stop(\"Expected a single string\")   }   n <- nchar(x)   if (n > max_len) {     stop(\"String is too long\")   }   c(charToRaw(x), rep(raw(1), max_len - n)) } char_from_raw <- function(x) {   rawToChar(x[x != raw(1)]) }  # Because max_len is the same thing as stride, wrap this all up a # little: char_buffer <- function(size, max_len) {   to <- function(x) char_to_raw(x, max_len)   ring_buffer_bytes_translate(size, max_len, to, char_from_raw) }  b <- char_buffer(100, 30) # 100 elements of up to 30 characters each b$push(\"x\") b$tail() #> [1] \"x\"  b$push(\"hello world!\") b$head() #> [1] \"hello world!\"  try(   b$push(\"supercalafragalisticexpealadocious\") ) # error: string is too long #> Error in char_to_raw(x, max_len) : String is too long"},{"path":"https://mrc-ide.github.io/ring/reference/ring_buffer_bytes_typed.html","id":null,"dir":"Reference","previous_headings":"","what":"Typed bytes ring buffer — ring_buffer_bytes_typed","title":"Typed bytes ring buffer — ring_buffer_bytes_typed","text":"Create ring buffer, backed ring_buffer_bytes, element corresponds fixed-size vector one R's atomic numeric types (logical, integer, double, complex).","code":""},{"path":"https://mrc-ide.github.io/ring/reference/ring_buffer_bytes_typed.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Typed bytes ring buffer — ring_buffer_bytes_typed","text":"","code":"ring_buffer_bytes_typed(size, what, len = NULL, on_overflow = \"overwrite\")"},{"path":"https://mrc-ide.github.io/ring/reference/ring_buffer_bytes_typed.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Typed bytes ring buffer — ring_buffer_bytes_typed","text":"size maximum number elements buffer can hold. element multiple bytes long. Either vector style vapply (e.g., integer(4) indicate element buffer 4-element integer, name storage mode len also provided. len given, length storage.  given, length() zero, storage mode used type.  Otherwise interpreted name storage mode (one \"logical\", \"integer\", \"double\" \"complex\". on_overflow Behaviour buffer overflow.  default overwrite oldest elements buffer (\"overwrite\").  Alternative actions \"error\" throw error function tries add elements space , \"grow\" grow buffer accept new elements (uses approximately golden ratio approach; see details ).","code":""},{"path":"https://mrc-ide.github.io/ring/reference/ring_buffer_bytes_typed.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Typed bytes ring buffer — ring_buffer_bytes_typed","text":"Note logical ring buffer integer ring buffer take number bytes logical vector stored integer (4 bytes per element) deal missing values; see \"writing R extensions\". Note possible store character vectors ring buffer type element character vector can number bytes.","code":""},{"path":"https://mrc-ide.github.io/ring/reference/ring_buffer_bytes_typed.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Typed bytes ring buffer — ring_buffer_bytes_typed","text":"Note methods reference section repeated verbatim three main ring buffer classes; ring_buffer_env (\"env\"), ring_buffer_bytes (\"bytes\") ring_buffer_bytes_typed (\"typed\").  Almost methods arguments behaviour, hopefully listing everything together, differences implementations bit apparent. reset Reset state buffer.  \"zeros\" head tail pointer (may may actually reset data) buffer can used fresh. Usage: reset(clear = FALSE) Arguments: clear:   Logical, indicating memory also cleared. Generally necessary, environment buffers can let garbage collector clean large elements.  bytes buffer zeros memory. Return value: Nothing; called side effect . duplicate Clone ring buffer, creating copy.  Copies underlying data position head tail. Usage: duplicate() Return value: new ring buffer object grow Increase size buffer n elements. Usage: bytes, typed: grow(n) env: grow(n, exact = FALSE) Arguments: n:   number additional elements space reserved (scalar non-negative integer).   Return value: Nothing; called side effect . size Return capacity (maximum size) ring buffer Usage: env: size() bytes, typed: size(bytes = FALSE) Arguments: bytes:   (ring_buffer_bytes ) Logical, indicating size returned bytes (rather logical entries, default). Return value: scalar integer bytes_data Return total size data storage used object. Usage: env: (supported) bytes, typed: bytes_data() Return value: scalar integer stride Length element ring buffer, bytes.  implemented (meaningful) bytes buffer; environment buffer support function makes sense . Usage: env: (supported) bytes, typed: stride() Return value: scalar integer used Return amount space used ring buffer. Usage: env: used() bytes, typed: used(bytes = FALSE) Arguments: bytes:   (ring_buffer_bytes ) Logical, indicating size returned bytes (rather logical entries, default). Return value: scalar integer free Return amount space free ring buffer. Usage: env: free() bytes, typed: free(bytes = FALSE) Arguments: bytes:   (ring_buffer_bytes ) Logical, indicating size returned bytes (rather logical entries, default). Return value: scalar integer is_empty Test ring buffer empty Usage: is_empty() Return value: scalar logical is_full Test ring buffer full Usage: is_full() Return value: scalar logical head_pos Return number entries \"start\" ring buffer head .  mostly useful debugging. Usage: env: head_pos() bytes, typed: head_pos(bytes = FALSE) Arguments: bytes:   (ring_buffer_bytes ) Logical, indicating position returned bytes (rather logical entries, default). Return value: scalar integer tail_pos Return number entries \"start\" ring buffer tail .  mostly useful debugging. Usage: env: tail_pos() bytes, typed: tail_pos(bytes = FALSE) Arguments: bytes:   (ring_buffer_bytes ) Logical, indicating position returned bytes (rather logical entries, default). Return value: scalar integer head Return contents head (recently written element ring buffer). Usage: head() Return value: depends little .  ring_buffer_env single R object.  ring_buffer_bytes raw vector, length stride ring buffer.  ring_buffer_bytes_typed, single R object translated raw. tail Return contents tail (least recently written element ring buffer). Usage: tail() Return value: head set Set number ring entries value.  exact behaviour varies depending type ring buffer.  function may overflow ring buffer; case tail moved. Usage: set(data, n) Arguments: data:   data set ring element .  environment buffer, may R object.  bytes buffer may either single byte (case ring element set byte, repeated stride times), raw vector length stride.   Return value: Invisibly returns number elements actually written (may less n buffer overflows).  Primarily called side effect. push Push elements onto ring buffer head.  may overflow ring buffer, destroying oldest elements buffer (moving position tail). Usage: env: push(data, iterate = TRUE) bytes, typed: push(data) Arguments: data:   Data push onto ring buffer.  ring_buffer_bytes, must raw vector length multiple buffer stride.  ring_buffer_bytes_typed must vector appropriate type.  ring_buffer_env may arbitrary R object (see iterate .   Return value: ring_buffer_bytes, data invisibly.  ring_buffer_bytes ring_buffer_bytes_typed, position head pointer (relative beginning storage region). take Destructively take elements ring buffer.  consumes tail (least recently added elements).  possibly underflow buffer; elements requested can supplied error thrown state buffer unmodified. Usage: take(n) Arguments: n:   number elements take. Return value: ring_buffer_env list n elements. ring_buffer_bytes, raw vector n * stride bytes.  ring_buffer_bytes_typed, vector n elements storage mode ring. read Nondestructively read elements ring buffer.  identical take except state buffer modified. Usage: read(n) Arguments: n:   number elements read. Return value: ring_buffer_env list n elements. ring_buffer_bytes, raw vector n * stride bytes.  ring_buffer_bytes_typed, vector n elements storage mode ring. copy Copy ring buffer different ring buffer. destructive respect ring buffers; tail pointer moved ring buffer data taken, destination ring buffer overflows, tail pointer moved . Usage: copy(dest, n) Arguments: dest:   destination ring buffer - modified call.   mirror Mirror contents ring buffer different ring buffer.  differs copy ring buffer unaffected ring buffer copied (including head/tail positions).  provides alternative way duplicating state duplicate already appropriately sized ring buffer handy.  allocations done. Usage: mirror(dest) Arguments: dest:   destination ring buffer - modified call. Return value: Nothing; called side effect . head_offset Nondestructively read contents head buffer, offset n entries. Usage: head_offset(n) Arguments: n:   Head offset.  moves away recently added item. offset 0 reads recently added element, 1 reads element added . Return value: head tail_offset Nondestructively read contents tail buffer, offset n entries. Usage: tail_offset(n) Arguments: n:   Tail offset.  moves away oldest item.  offset 0 reads oldest element, 1 reads element added . Return value: tail (see head) take_head take, operating head rather tail.  destructive respect head. Usage: take_head(n) Arguments: n:   Number elements take. Return value: take read_head read, operating head rather tail.  destructive respect tail. Usage: read_head(n) Arguments: n:   Number elements read. Return value: read head_set Set data head without advancing.  useful cases head data set advanced separately (head_advance).  unlikely useful users.  used extensively dde (called C). Usage: head_set(data) Arguments: data:   Data set head.  bytes buffer must exactly stride bytes long, environment buffer corresponds single \"element\". Return value: Nothing; called side effect . head_data Retrieve current data stored head advanced. many cases may junk - byte buffer looped bytes overwritten next write.  However, using head_set data set buffer yet committed head_advance. Usage: head_data() Return value: head head_advance Shift head around one position.  commits data written head_set. Usage: head_advance() Return value: Nothing; called side effect .","code":"\\item{\\code{exact}:   (For bytes buffer only) Logical scalar indicating if growth should increase the size by \\emph{exactly} \\code{n} elements (if \\code{TRUE}) or so that \\emph{at least} \\code{n} additional elements will fit (growing the buffer geometrically if needed). } \\item{\\code{n}:   The number of entries to set to \\code{data} } \\item{\\code{iterate}:   For \\code{ring_buffer_env} only, changes the behaviour with vectors and lists.  Because each element of a \\code{ring_buffer_env} can b an arbitrary R object, for a list \\code{x} it is ambiguous if \\code{push(x)} should push one object onto the buffer, or \\code{length(x)} objects (i.e. equivalent to \\code{push(x[[1]])}, \\code{push(x[[2]])}, etc.  The \\code{iterate} argument switches between interpretations; if \\code{TRUE} (the default) the push will iterate over the object using \\code{for (el in x)} (with appropriate S3 dispatch).  If \\code{iterate = FALSE}, then the entire object is pushed at once, so always updating only by a single element. } \\item{\\code{n}:   The number of elements to copy }"},{"path":"https://mrc-ide.github.io/ring/reference/ring_buffer_bytes_typed.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Typed bytes ring buffer — ring_buffer_bytes_typed","text":"Rich FitzJohn","code":""},{"path":"https://mrc-ide.github.io/ring/reference/ring_buffer_bytes_typed.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Typed bytes ring buffer — ring_buffer_bytes_typed","text":"","code":"# Create a ring buffer of 30 integers: b <- ring_buffer_bytes_typed(30, integer(1))  # Alternatively you can create the same buffer this way: b <- ring_buffer_bytes_typed(30, \"integer\", 1)  # The buffer is empty to start with b$is_empty() #> [1] TRUE  # Note that the buffer has a stride of 4 (see ?ring_buffer_bytes) b$stride() #> [1] 4  # Push some numbers into the buffer: b$push(as.integer(1:10))  # Report the number of elements used: b$used() #> [1] 10  # Get the first added element: b$tail() #> [1] 1  # The buffer behaves basically the same way now as # \"ring_buffer_env\" but will typecheck all inputs: if (FALSE) { # \\dontrun{   b$push(pi) # error because not an integer   b$push(1)  # error because not an integer (you must convert to int) } # }  # Recycling: the typed buffer operates by converting the input # vector to a set of bytes and then pushing them onto the buffer; # this works so long as the vector of bytes has the correct # length. b <- ring_buffer_bytes_typed(30, integer(3))  # These both fail because 2 and 4 do not end up as multiples of 3: if (FALSE) { # \\dontrun{   b$push(c(1L, 2L))   b$push(c(1L, 2L, 3L, 4L)) } # }  # But this is fine: b$push(seq_len(6)) b$tail() #> [1] 1 2 3 b$tail_offset(1) #> [1] 4 5 6"},{"path":"https://mrc-ide.github.io/ring/reference/ring_buffer_env.html","id":null,"dir":"Reference","previous_headings":"","what":"Environment-based ring buffer — ring_buffer_env","title":"Environment-based ring buffer — ring_buffer_env","text":"environment based ring buffer.  contrast ring_buffer_bytes, ring buffer truly circular, implemented doubly linked list loops back .  element ring buffer can hold arbitrary R object, checking done make sure objects similar types; way similar circular version R list.","code":""},{"path":"https://mrc-ide.github.io/ring/reference/ring_buffer_env.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Environment-based ring buffer — ring_buffer_env","text":"","code":"ring_buffer_env(size, on_overflow = \"overwrite\")"},{"path":"https://mrc-ide.github.io/ring/reference/ring_buffer_env.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Environment-based ring buffer — ring_buffer_env","text":"size (maximum) number entries buffer can contain. on_overflow Behaviour buffer overflow.  default overwrite oldest elements buffer (\"overwrite\").  Alternative actions \"error\" throw error function tries add elements space , \"grow\" grow buffer accept new elements.","code":""},{"path":"https://mrc-ide.github.io/ring/reference/ring_buffer_env.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Environment-based ring buffer — ring_buffer_env","text":"pushing objects onto buffer, must careful iterate argument.  default object length() greater 1 $push() iterate object (equivalent $push(data[[1]], iterate=FALSE), $push(data[[2]], iterate=FALSE), ). information usage examples, see vignette (vignette(\"ring\")). underflow (overflow on_overflow = \"error\") ring raise custom exceptions can caught specially tryCatch.  class ring_underflow (ring_overflow overflow).  supported bytes buffer yet.  See examples usage.","code":""},{"path":"https://mrc-ide.github.io/ring/reference/ring_buffer_env.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Environment-based ring buffer — ring_buffer_env","text":"Note methods reference section repeated verbatim three main ring buffer classes; ring_buffer_env (\"env\"), ring_buffer_bytes (\"bytes\") ring_buffer_bytes_typed (\"typed\").  Almost methods arguments behaviour, hopefully listing everything together, differences implementations bit apparent. reset Reset state buffer.  \"zeros\" head tail pointer (may may actually reset data) buffer can used fresh. Usage: reset(clear = FALSE) Arguments: clear:   Logical, indicating memory also cleared. Generally necessary, environment buffers can let garbage collector clean large elements.  bytes buffer zeros memory. Return value: Nothing; called side effect . duplicate Clone ring buffer, creating copy.  Copies underlying data position head tail. Usage: duplicate() Return value: new ring buffer object grow Increase size buffer n elements. Usage: bytes, typed: grow(n) env: grow(n, exact = FALSE) Arguments: n:   number additional elements space reserved (scalar non-negative integer).   Return value: Nothing; called side effect . size Return capacity (maximum size) ring buffer Usage: env: size() bytes, typed: size(bytes = FALSE) Arguments: bytes:   (ring_buffer_bytes ) Logical, indicating size returned bytes (rather logical entries, default). Return value: scalar integer bytes_data Return total size data storage used object. Usage: env: (supported) bytes, typed: bytes_data() Return value: scalar integer stride Length element ring buffer, bytes.  implemented (meaningful) bytes buffer; environment buffer support function makes sense . Usage: env: (supported) bytes, typed: stride() Return value: scalar integer used Return amount space used ring buffer. Usage: env: used() bytes, typed: used(bytes = FALSE) Arguments: bytes:   (ring_buffer_bytes ) Logical, indicating size returned bytes (rather logical entries, default). Return value: scalar integer free Return amount space free ring buffer. Usage: env: free() bytes, typed: free(bytes = FALSE) Arguments: bytes:   (ring_buffer_bytes ) Logical, indicating size returned bytes (rather logical entries, default). Return value: scalar integer is_empty Test ring buffer empty Usage: is_empty() Return value: scalar logical is_full Test ring buffer full Usage: is_full() Return value: scalar logical head_pos Return number entries \"start\" ring buffer head .  mostly useful debugging. Usage: env: head_pos() bytes, typed: head_pos(bytes = FALSE) Arguments: bytes:   (ring_buffer_bytes ) Logical, indicating position returned bytes (rather logical entries, default). Return value: scalar integer tail_pos Return number entries \"start\" ring buffer tail .  mostly useful debugging. Usage: env: tail_pos() bytes, typed: tail_pos(bytes = FALSE) Arguments: bytes:   (ring_buffer_bytes ) Logical, indicating position returned bytes (rather logical entries, default). Return value: scalar integer head Return contents head (recently written element ring buffer). Usage: head() Return value: depends little .  ring_buffer_env single R object.  ring_buffer_bytes raw vector, length stride ring buffer.  ring_buffer_bytes_typed, single R object translated raw. tail Return contents tail (least recently written element ring buffer). Usage: tail() Return value: head set Set number ring entries value.  exact behaviour varies depending type ring buffer.  function may overflow ring buffer; case tail moved. Usage: set(data, n) Arguments: data:   data set ring element .  environment buffer, may R object.  bytes buffer may either single byte (case ring element set byte, repeated stride times), raw vector length stride.   Return value: Invisibly returns number elements actually written (may less n buffer overflows).  Primarily called side effect. push Push elements onto ring buffer head.  may overflow ring buffer, destroying oldest elements buffer (moving position tail). Usage: env: push(data, iterate = TRUE) bytes, typed: push(data) Arguments: data:   Data push onto ring buffer.  ring_buffer_bytes, must raw vector length multiple buffer stride.  ring_buffer_bytes_typed must vector appropriate type.  ring_buffer_env may arbitrary R object (see iterate .   Return value: ring_buffer_bytes, data invisibly.  ring_buffer_bytes ring_buffer_bytes_typed, position head pointer (relative beginning storage region). take Destructively take elements ring buffer.  consumes tail (least recently added elements).  possibly underflow buffer; elements requested can supplied error thrown state buffer unmodified. Usage: take(n) Arguments: n:   number elements take. Return value: ring_buffer_env list n elements. ring_buffer_bytes, raw vector n * stride bytes.  ring_buffer_bytes_typed, vector n elements storage mode ring. read Nondestructively read elements ring buffer.  identical take except state buffer modified. Usage: read(n) Arguments: n:   number elements read. Return value: ring_buffer_env list n elements. ring_buffer_bytes, raw vector n * stride bytes.  ring_buffer_bytes_typed, vector n elements storage mode ring. copy Copy ring buffer different ring buffer. destructive respect ring buffers; tail pointer moved ring buffer data taken, destination ring buffer overflows, tail pointer moved . Usage: copy(dest, n) Arguments: dest:   destination ring buffer - modified call.   mirror Mirror contents ring buffer different ring buffer.  differs copy ring buffer unaffected ring buffer copied (including head/tail positions).  provides alternative way duplicating state duplicate already appropriately sized ring buffer handy.  allocations done. Usage: mirror(dest) Arguments: dest:   destination ring buffer - modified call. Return value: Nothing; called side effect . head_offset Nondestructively read contents head buffer, offset n entries. Usage: head_offset(n) Arguments: n:   Head offset.  moves away recently added item. offset 0 reads recently added element, 1 reads element added . Return value: head tail_offset Nondestructively read contents tail buffer, offset n entries. Usage: tail_offset(n) Arguments: n:   Tail offset.  moves away oldest item.  offset 0 reads oldest element, 1 reads element added . Return value: tail (see head) take_head take, operating head rather tail.  destructive respect head. Usage: take_head(n) Arguments: n:   Number elements take. Return value: take read_head read, operating head rather tail.  destructive respect tail. Usage: read_head(n) Arguments: n:   Number elements read. Return value: read head_set Set data head without advancing.  useful cases head data set advanced separately (head_advance).  unlikely useful users.  used extensively dde (called C). Usage: head_set(data) Arguments: data:   Data set head.  bytes buffer must exactly stride bytes long, environment buffer corresponds single \"element\". Return value: Nothing; called side effect . head_data Retrieve current data stored head advanced. many cases may junk - byte buffer looped bytes overwritten next write.  However, using head_set data set buffer yet committed head_advance. Usage: head_data() Return value: head head_advance Shift head around one position.  commits data written head_set. Usage: head_advance() Return value: Nothing; called side effect .","code":"\\item{\\code{exact}:   (For bytes buffer only) Logical scalar indicating if growth should increase the size by \\emph{exactly} \\code{n} elements (if \\code{TRUE}) or so that \\emph{at least} \\code{n} additional elements will fit (growing the buffer geometrically if needed). } \\item{\\code{n}:   The number of entries to set to \\code{data} } \\item{\\code{iterate}:   For \\code{ring_buffer_env} only, changes the behaviour with vectors and lists.  Because each element of a \\code{ring_buffer_env} can b an arbitrary R object, for a list \\code{x} it is ambiguous if \\code{push(x)} should push one object onto the buffer, or \\code{length(x)} objects (i.e. equivalent to \\code{push(x[[1]])}, \\code{push(x[[2]])}, etc.  The \\code{iterate} argument switches between interpretations; if \\code{TRUE} (the default) the push will iterate over the object using \\code{for (el in x)} (with appropriate S3 dispatch).  If \\code{iterate = FALSE}, then the entire object is pushed at once, so always updating only by a single element. } \\item{\\code{n}:   The number of elements to copy }"},{"path":"https://mrc-ide.github.io/ring/reference/ring_buffer_env.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Environment-based ring buffer — ring_buffer_env","text":"Rich FitzJohn","code":""},{"path":"https://mrc-ide.github.io/ring/reference/ring_buffer_env.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Environment-based ring buffer — ring_buffer_env","text":"","code":"buf <- ring_buffer_env(10) buf$push(1:10) buf$take(3) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 2 #>  #> [[3]] #> [1] 3 #>  buf$push(11:15) buf$take(2) #> [[1]] #> [1] 6 #>  #> [[2]] #> [1] 7 #>   # The \"on_overflow\" argument by default allows for the buffer to # overwrite on overflow. buf <- ring_buffer_env(10) buf$push(1:10) unlist(buf$read(buf$used())) # 1:10 #>  [1]  1  2  3  4  5  6  7  8  9 10 # Over-write the first 5 buf$push(11:15) unlist(buf$read(buf$used())) # 6:15 #>  [1]  6  7  8  9 10 11 12 13 14 15  # Unlike ring_buffer_bytes, these ring buffers can hold any R # object.  However, you must be careful about use of iterate! buf$push(lm(mpg ~ cyl, mtcars), iterate = FALSE) buf$take(1) #> [[1]] #> [1] 7 #>   # Alternatively, grow the buffer as overwriting happens buf <- ring_buffer_env(10, \"grow\") buf$push(1:10) buf$push(11:15) unlist(buf$read(buf$used())) # 1:15 #>  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15  # Or throw an error on overflow buf <- ring_buffer_env(10, \"error\") buf$push(1:10) try(buf$push(11:15)) #> Error : Buffer overflow (requested 5 elements but 0 available)  # The errors that are thrown on underflow / overflow are typed so # can be caught by tryCatch: tryCatch(buf$read(100),          ring_underflow = function(e) message(\"nope\")) #> nope tryCatch(buf$push(100),          ring_overflow = function(e) message(\"nope again\")) #> nope again"},{"path":"https://mrc-ide.github.io/ring/news/index.html","id":"ring-105","dir":"Changelog","previous_headings":"","what":"ring 1.0.5","title":"ring 1.0.5","text":"CRAN release: 2023-11-29 Avoid platform dependent sprintf format code","code":""},{"path":"https://mrc-ide.github.io/ring/news/index.html","id":"ring-104","dir":"Changelog","previous_headings":"","what":"ring 1.0.4","title":"ring 1.0.4","text":"CRAN release: 2023-04-28 Package can built strict R headers ","code":""},{"path":"https://mrc-ide.github.io/ring/news/index.html","id":"ring-103","dir":"Changelog","previous_headings":"","what":"ring 1.0.3","title":"ring 1.0.3","text":"CRAN release: 2021-06-15 Package DESCRIPTION longer LazyData field","code":""},{"path":"https://mrc-ide.github.io/ring/news/index.html","id":"ring-102","dir":"Changelog","previous_headings":"","what":"ring 1.0.2","title":"ring 1.0.2","text":"Fix crash reading rings containing 2^31 bytes","code":""},{"path":"https://mrc-ide.github.io/ring/news/index.html","id":"ring-101","dir":"Changelog","previous_headings":"","what":"ring 1.0.1","title":"ring 1.0.1","text":"Several small safety tweaks preventing crashes (#13)","code":""},{"path":"https://mrc-ide.github.io/ring/news/index.html","id":"ring-100-2017-04-24","dir":"Changelog","previous_headings":"","what":"ring 1.0.0 (2017-04-24)","title":"ring 1.0.0 (2017-04-24)","text":"CRAN release: 2017-04-24 Initial CRAN release","code":""}]
